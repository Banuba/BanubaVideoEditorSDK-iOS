// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.1 (swiftlang-1200.0.41 clang-1200.0.32.8)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name BanubaVideoEditorSDK
import ARKit
import AVFoundation
import AVKit
import BanubaEffectPlayer
import BanubaMusicEditorSDK
import BanubaOverlayEditorSDK
import BanubaSdk
@_exported import BanubaVideoEditorSDK
import CoreGraphics
import CoreMedia
import CoreVideo
import Foundation
import GLKit
import MobileCoreServices
import OpenGLES
import Photos
import Swift
import UIKit
import VideoEditor
@objc @_inheritsConvenienceInitializers public class VideoEditorActivityIndicator : UIKit.UIView {
  @objc override dynamic public var bounds: CoreGraphics.CGRect {
    @objc get
    @objc set
  }
  public var configuration: SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public func startAnimating()
  public func stopAnimating()
  @objc deinit
}
public protocol SDKMaskPostprocessServicing : AnyObject {
  func postprocessProcessVideoFrame(_ from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, time: CoreMedia.CMTime)
  func postprocessStopVideoProcessing()
  func postprocessPlaybackStop()
  func postprocessSurfaceDestroyed()
  func postprocessSurfaceCreated(with size: CoreGraphics.CGSize)
  func postprocessSetEffectSize(_ size: CoreGraphics.CGSize)
  func postprocessLoadEffect(path: Swift.String)
  func postprocessStartVideoProcessing(with size: CoreGraphics.CGSize)
  func postprocessDraw()
}
public struct VideoOverlayObjectWithImage : OverlayItem {
  public let id: Swift.String
  public var image: UIKit.UIImage
  public var imageData: Foundation.Data
  public var startTime: CoreMedia.CMTime
  public var endTime: CoreMedia.CMTime
  public var presentationStyle: OverlayItemPresentationStyle {
    get
  }
  public var isEditable: Swift.Bool {
    get
  }
  public var frame: CoreGraphics.CGRect
  public var transform: CoreGraphics.CGAffineTransform
  public init(id: Swift.String, image: UIKit.UIImage, imageData: Foundation.Data, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, frame: CoreGraphics.CGRect = .zero, transform: CoreGraphics.CGAffineTransform = .identity)
}
@_inheritsConvenienceInitializers public class BanubaMaskDrawer : VideoEditorEffectDrawer {
  @objc deinit
  required public init()
}
extension PlayersBundle : PlayerAdoptable {
}
public struct VideoOverlayObjectWithText : OverlayItem {
  public let id: Swift.String
  public var image: UIKit.UIImage
  public var startTime: CoreMedia.CMTime
  public var endTime: CoreMedia.CMTime
  public var presentationStyle: OverlayItemPresentationStyle {
    get
  }
  public var isEditable: Swift.Bool {
    get
  }
  public var text: Swift.String?
  public var font: VideoTextFont?
  public var backgroundColor: UIKit.UIColor?
  public var foregroundColor: UIKit.UIColor?
  public var alignment: UIKit.NSTextAlignment?
  public var frame: CoreGraphics.CGRect
  public var transform: CoreGraphics.CGAffineTransform
  public init()
  public init(image: UIKit.UIImage)
}
@objc @_inheritsConvenienceInitializers public class FullscreenActivityView : UIKit.UIView {
  public var text: Swift.String? {
    get
    set
  }
  public var configuration: FullScreenActivityConfiguration? {
    get
    set
  }
  @objc override dynamic public func awakeFromNib()
  public func applyVisibility(_ visible: Swift.Bool)
  public static func loadFromNib() -> FullscreenActivityView
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@_hasMissingDesignatedInitializers public class EditorEffectModelBuilder {
  public func gifModel(id: Swift.UInt, rendererInstance: CompositionRenderering?) -> VideoEditorFilterModel
  public func textModel(id: Swift.UInt, rendererInstance: CompositionRenderering?) -> VideoEditorFilterModel
  public func makeModels(configs: [[EditorEffectKey : Any]], startId: Swift.UInt) -> [VideoEditorFilterModel]
  public func makeModel(config: [EditorEffectKey : Any], id: Swift.UInt) -> VideoEditorFilterModel
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AlertViewController : UIKit.UIViewController {
  public enum AlertType {
    case info
    case selection
    public static func == (a: AlertViewController.AlertType, b: AlertViewController.AlertType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var messageText: Swift.String? {
    get
    set
  }
  public var alertType: AlertViewController.AlertType? {
    get
    set
  }
  public var configuration: AlertViewConfiguration?
  public var actionHandler: ((Swift.Bool) -> Swift.Void)?
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@_hasMissingDesignatedInitializers public class VideoOverlayObjectRepository {
  public func getAll() -> [OverlayItem]
  public func get(by id: Swift.String) -> OverlayItem?
  public func save(overlayItem: OverlayItem)
  public func remove(by id: Swift.String)
  public func removeAll()
  @objc deinit
}
public class AudioServiceItem {
  final public let url: Foundation.URL
  final public let title: Swift.String?
  final public let id: Swift.Int64
  public var timeRange: CoreMedia.CMTimeRange {
    get
  }
  public init(url: Foundation.URL, id: Swift.Int64, title: Swift.String?)
  @objc deinit
}
public protocol AudioServicing {
  var delegate: AudioPlayerDelegate? { get set }
  var currentAudio: AudioServiceItem? { get }
  var duration: Foundation.TimeInterval? { get }
  func autoRepeat(repeat: Swift.Bool)
  func seekToStart()
  func seek(to: Foundation.TimeInterval)
  func load(item: AudioServiceItem) throws
  func unload()
  func toggle()
  func play()
  func pause()
  func setDelegate(_ delegate: AudioPlayerDelegate)
}
@objc @_inheritsConvenienceInitializers public class AudioService : ObjectiveC.NSObject, AudioServicing, AudioEditorServiceAdoptable {
  weak public var delegate: AudioPlayerDelegate?
  public var currentAudio: AudioServiceItem?
  public var player: AVFoundation.AVAudioPlayer?
  public var duration: Foundation.TimeInterval? {
    get
  }
  public func autoRepeat(repeat: Swift.Bool)
  public func seekToStart(isEnabled: Swift.Bool)
  public func load(track: AudioTrackAdoptable) throws
  public func createAudioDirectory()
  public func changeVolume(volume: Swift.Float)
  public func load(item: AudioServiceItem) throws
  public func unload()
  public func toggle()
  public func play()
  public func pause()
  public func seekToStart()
  public func seek(to: Foundation.TimeInterval)
  public func setDelegate(_ delegate: AudioPlayerDelegate)
  @objc deinit
  @objc override dynamic public init()
}
extension AudioService : AVFoundation.AVAudioPlayerDelegate {
  @objc dynamic public func audioPlayerDidFinishPlaying(_ player: AVFoundation.AVAudioPlayer, successfully flag: Swift.Bool)
}
public class BanubaCameraModule {
  final public let mode: SDKInputServiceMode
  public var beautyManager: BeautyEffectManaging
  public var isLoaded: Swift.Bool
  public var isStarted: Swift.Bool {
    get
  }
  public var allowProcessing: Swift.Bool
  public var inputDelegate: SDKInputServicingDelegate?
  public var inputARDelegate: SDKARInputServicingDelegate?
  required public init()
  @objc deinit
}
extension BanubaCameraModule : CameraModule {
  public var autoStart: Swift.Bool {
    get
    set
  }
  public var playerViewSize: CoreGraphics.CGSize {
    get
  }
  public func setup(postproccessContext: OpenGLES.EAGLContext)
  public func destroy()
  public func takeSnapshot(handler: @escaping (UIKit.UIImage) -> Swift.Void)
  public func start(completion: @escaping () -> Swift.Void)
  public func stop(completion: (() -> Swift.Void)?)
  public func setRenderTarget(view: UIKit.UIView)
  public func removeRenderTarget()
  public func makeCameraPhoto(cameraSettings: CameraModulePhotoSettings, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  public func getRendererView() -> UIKit.UIView
}
extension BanubaCameraModule : SDKInputServicing {
  public var zoomFactor: Swift.Float {
    get
  }
  public var isFrontCamera: Swift.Bool {
    get
  }
  public var currentCameraSessionType: CameraModuleSessionType {
    get
  }
  public func configureFocusSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  public func configureExposureSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  public func setZoomFactor(_ zoomFactor: Swift.Float) -> Swift.Float
  public func toggleCamera()
  public func startCamera()
  public func startAudioCapturing()
  public func stopAudioCapturing()
  public func setCameraSessionType(_ type: CameraModuleSessionType)
  public func setTorch(mode: AVFoundation.AVCaptureDevice.TorchMode) -> AVFoundation.AVCaptureDevice.TorchMode
  public func toggleTorch() -> AVFoundation.AVCaptureDevice.TorchMode
}
extension BanubaCameraModule : SDKOutputServicing {
  public var isRecording: Swift.Bool {
    get
  }
  public var isEnoughDiskSpaceForRecording: Swift.Bool {
    get
  }
  public func startVideoCapturing(fileURL: Foundation.URL?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  public func startVideoCapturing(fileURL: Foundation.URL?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, periodicProgressTimeInterval: Foundation.TimeInterval, boundaryTimes: [Foundation.NSValue], boundaryHandler: @escaping (CoreMedia.CMTime) -> Swift.Void, totalDuration: Foundation.TimeInterval, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  public func stopVideoCapturing(cancel: Swift.Bool)
}
extension BanubaCameraModule : SDKEffectsServicing {
  public func loadMask(name: Swift.String) -> EffectConfigProtocol?
  public func unloadMask()
  public func removeAllFilters()
  public func applyFilter(_ filter: EffectModel)
  public func removeFilter(_ filter: EffectModel)
  public func setText(_ text: Swift.String, color: UIKit.UIColor, area: EffectTextAreaConfig)
  public func setEffectSubtypeModificationsEventListener(_ listener: EffectSubtypeModificationsEventListener)
  public func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
}
extension BanubaCameraModule : SDKBeautyEffectManaging {
  public var isBeatificationEnabled: Swift.Bool {
    get
    set
  }
  public func toggleBeautification() -> Swift.Bool
}
extension BanubaCameraModule : BanubaSdkEffectEventListener {
  public func didTouch(eventName: Swift.String, parameters: [Swift.String : Swift.String])
}
extension BanubaCameraModule : BanubaSdkDelegate {
  public func willOutput(pixelBuffer: CoreVideo.CVPixelBuffer)
}
extension BanubaCameraModule : SDKMaskPostprocessServicing {
  public func postprocessProcessVideoFrame(_ from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, time: CoreMedia.CMTime)
  public func postprocessStopVideoProcessing()
  public func postprocessPlaybackStop()
  public func postprocessSurfaceDestroyed()
  public func postprocessSurfaceCreated(with size: CoreGraphics.CGSize)
  public func postprocessSetEffectSize(_ size: CoreGraphics.CGSize)
  public func postprocessLoadEffect(path: Swift.String)
  public func postprocessStartVideoProcessing(with size: CoreGraphics.CGSize)
  public func postprocessDraw()
}
final public class ApplicationInformation {
  required public init(bundle: Foundation.Bundle)
  final public var version: Swift.String {
    get
  }
  final public var build: Swift.String {
    get
  }
  final public var fullVersion: Swift.String {
    get
  }
  @objc deinit
}
public enum AudioWriterStatus {
  case prepare
  case ready
  case capturing
  case completed
  case failed
  public static func == (a: AudioWriterStatus, b: AudioWriterStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol AudioWriterDelegate : AudioWriterAdoptableDelegate {
  func audioWriter(_ audioWriter: AudioWriterAdoptable, didFailWithError error: Swift.Error)
  func audioWriter(_ audioWriter: AudioWriterAdoptable, didFinishRecording successful: Swift.Bool)
  func audioWriterDidStartRecording(_ audioWriter: AudioWriterAdoptable)
}
@objc public class AudioWriter : ObjectiveC.NSObject, AudioWriterAdoptable {
  weak public var delegate: AudioWriterAdoptableDelegate?
  public var fileUrl: Foundation.URL?
  required public init(file url: Foundation.URL?)
  @objc deinit
  public func deleteAudioRecording()
  public func resetAudioWriter()
  public func setupUrl(file url: Foundation.URL)
  public func prepare()
  public func startCapturing(forDuration duration: Foundation.TimeInterval?)
  public func stopCapturing()
  @objc override dynamic public init()
}
extension AudioWriter : AVFoundation.AVAudioRecorderDelegate {
  @objc dynamic public func audioRecorderEncodeErrorDidOccur(_ recorder: AVFoundation.AVAudioRecorder, error: Swift.Error?)
  @objc dynamic public func audioRecorderDidFinishRecording(_ recorder: AVFoundation.AVAudioRecorder, successfully flag: Swift.Bool)
}
public protocol BanubaVideoEditorSDKDelegate : AnyObject {
  func videoEditorDidCancel(_ videoEditor: BanubaVideoEditorSDK)
  func videoEditorDone(_ videoEditor: BanubaVideoEditorSDK)
}
public class BanubaVideoEditorSDK {
  weak public var delegate: BanubaVideoEditorSDKDelegate?
  public var sdk: SDKService {
    get
  }
  public var musicMetadata: MusicEditorMetadata? {
    get
  }
  public var metadata: VideoEditorMetadata? {
    get
  }
  public var asset: AVFoundation.AVAsset? {
    get
  }
  public var musicTrack: MediaTrack? {
    get
  }
  public var imageGenerator: AVFoundation.AVAssetImageGenerator? {
    get
  }
  public var currentConfiguration: VideoEditorConfig {
    get
  }
  public init(token: Swift.String, effectsToken: Swift.String, configuration: VideoEditorConfig, camera: CameraModule? = nil, analytics: AnalyticsEngine? = nil, externalViewControllerFactory: ExternalViewControllerFactory? = nil)
  public func exportVideo(fileUrl: Foundation.URL, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  public func exportVideoWithCoverImage(fileUrl: Foundation.URL, completion: @escaping (Swift.Bool, Swift.Error?, UIKit.UIImage) -> Swift.Void)
  public func exportVideos(using configurations: [ExportVideoConfiguration], completion: ((Swift.Bool, Swift.Error?) -> Swift.Void)?)
  public func exportVideosWithCoverImage(using configurations: [ExportVideoConfiguration], completion: ((Swift.Bool, Swift.Error?, UIKit.UIImage) -> Swift.Void)?)
  public func exportAudio(fileUrl: Foundation.URL, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  public func clearSessionData()
  public func dismissVideoEditor(animated: Swift.Bool, completion: (() -> Swift.Void)?)
  public func presentVideoEditor(from hostController: UIKit.UIViewController, animated: Swift.Bool, musicTrack: MediaTrack? = nil, completion: (() -> Swift.Void)?)
  public func updateVideoEditorConfig(_ config: VideoEditorConfig)
  @objc deinit
}
extension BanubaVideoEditorSDK {
  public func cameraViewControllerDidCancel(_ controller: UIKit.UIViewController)
  public func cameraViewControllerDidFinish(_ controller: UIKit.UIViewController)
  public func cameraViewController(_ controller: UIKit.UIViewController, didRequestMask mask: CameraMask, statusUpdateHandler: ((CameraMaskStatus) -> Swift.Void)?)
}
public protocol EffectSubtypeModificationsEventListener : AnyObject {
  func didChangeEffectSubtype(_ subtypeName: Swift.String)
  func didInitiateEffectSubtype(_ subtypeName: Swift.String)
}
public protocol SDKEffectsServicing : AnyObject {
  func loadMask(name: Swift.String) -> EffectConfigProtocol?
  func unloadMask()
  func removeAllFilters()
  func applyFilter(_ filter: EffectModel)
  func removeFilter(_ filter: EffectModel)
  func setText(_ text: Swift.String, color: UIKit.UIColor, area: EffectTextAreaConfig)
  func setEffectSubtypeModificationsEventListener(_ listener: EffectSubtypeModificationsEventListener)
  func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
}
public class TextEditSelectionBorderAnimationBehavior : TextEditSelectionColorBehavior {
  final public let defaultBorderWidth: CoreGraphics.CGFloat
  final public let selectedBorderWidth: CoreGraphics.CGFloat
  public init(defaultBorderWidth: CoreGraphics.CGFloat, selectedBorderWidth: CoreGraphics.CGFloat)
  public func setColorView(_ colorView: UIKit.UIView, selected: Swift.Bool, animated: Swift.Bool)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CountdownView : UIKit.UIView, CountdownTimerAnimatableView {
  public var font: UIKit.UIFont {
    get
    set
  }
  @objc override dynamic public func draw(_ rect: CoreGraphics.CGRect)
  @objc deinit
}
extension CountdownView {
  public var countdownDigit: Swift.Int {
    get
    set
  }
  public var digitColor: UIKit.UIColor {
    get
    set
  }
  public func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  public func stop()
}
public enum CameraAlertType {
  case deleteSegment
  case discardFilters
  case discardChanges
  case discardEffects
  case requestGalleryPermissions
  case requestGalleryPhotoPermissions
  case noCameraPermissions
  case cameraAccessRestricted
  case noMicrophonePermissions
  case noGalleryPermissions
  case notFinishedVideo
  case discardAll
  public var message: Swift.String {
    get
  }
  public var title: Swift.String {
    get
  }
  public var actionTitle: Swift.String {
    get
  }
  public var actionStyle: UIKit.UIAlertAction.Style {
    get
  }
  public var cancelActionTitle: Swift.String {
    get
  }
  public static func == (a: CameraAlertType, b: CameraAlertType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension UIViewController {
  public func presentAlert(type: CameraAlertType, completion: ((Swift.Bool) -> Swift.Void)?)
}
public protocol SDKCameraChangedDelegate : AnyObject {
  func sdkDidChangeCamera(cameraStartedCompletion: (() -> Swift.Void)?)
  func sdkWillChangeCamera()
}
public protocol SDKServicing : AnyObject {
  var isLoaded: Swift.Bool { get }
  var metadataService: VideoMetadataStorage { get }
  var inputService: SDKInputServicing { get }
  var outputService: SDKOutputServicing { get }
  var editorSequenceService: VideoSequenceServicing { get }
  var effectsService: SDKEffectsServicing { get }
  var videoEditorService: VideoEditorService { get }
  var beautyManager: SDKBeautyEffectManaging { get }
  var audioService: AudioServicing { get }
  var playerViewSize: CoreGraphics.CGSize { get }
  var autoStart: Swift.Bool { get set }
  var allowProcessing: Swift.Bool { get set }
  var videoRecordSpeed: VideoRecordSpeed { get set }
  var isStarted: Swift.Bool { get }
  var isARCameraSupported: Swift.Bool { get }
  var cameraChangedDelegate: SDKCameraChangedDelegate? { get set }
  func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
  func setup()
  func destroy()
  func start(completion: @escaping () -> Swift.Void)
  func stop()
  func stop(completion: (() -> Swift.Void)?)
  func applyFilter(_ filter: EffectModel)
  func removeFilter(_ filter: EffectModel)
  func removeAllFilters()
  func loadMask(name: Swift.String) -> EffectConfigProtocol?
  func unloadMask()
  func setRenderTarget(view: UIKit.UIView)
  func removeRenderTarget()
  func toggleBeautification() -> Swift.Bool
  func discardAppliedChanges()
  func configurePhotoModeIfNeeded(isFrontCamera: Swift.Bool, isEnableTorch: Swift.Bool)
  func makeCameraPhoto(cameraSettings: CameraModulePhotoSettings, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  func getRendererView() -> UIKit.UIView
  func setText(_ text: Swift.String, color: UIKit.UIColor, area: EffectTextAreaConfig)
  func takeSnapshot(handler: @escaping (UIKit.UIImage) -> Swift.Void)
  func replaceCamera(_ camera: CameraModule, completion: (() -> Swift.Void)?)
}
public class SDKService : SDKServicing {
  weak public var cameraChangedDelegate: SDKCameraChangedDelegate?
  public var metadataService: VideoMetadataStorage
  public var videoRecordSpeed: VideoRecordSpeed
  public var isStarted: Swift.Bool {
    get
  }
  public var isARCameraSupported: Swift.Bool {
    get
  }
  public var allowProcessing: Swift.Bool {
    get
    set
  }
  public var isLoaded: Swift.Bool {
    get
  }
  public var beautyManager: SDKBeautyEffectManaging {
    get
  }
  public var inputService: SDKInputServicing {
    get
  }
  public var outputService: SDKOutputServicing {
    get
  }
  public var editorSequenceService: VideoSequenceServicing {
    get
  }
  public var effectsService: SDKEffectsServicing {
    get
  }
  public var videoEditorService: VideoEditorService {
    get
  }
  public var audioService: AudioServicing {
    get
  }
  public var autoStart: Swift.Bool {
    get
    set
  }
  public var playerViewSize: CoreGraphics.CGSize {
    get
  }
  required public init(cameraModule: CameraModule)
  public func setup()
  public func destroy()
  public func start(completion: @escaping () -> Swift.Void)
  public func stop()
  public func stop(completion: (() -> Swift.Void)?)
  public func applyFilter(_ filter: EffectModel)
  public func removeFilter(_ filter: EffectModel)
  public func removeAllFilters()
  public func takeSnapshot(handler: @escaping (UIKit.UIImage) -> Swift.Void)
  public func loadMask(name: Swift.String) -> EffectConfigProtocol?
  public func unloadMask()
  public func setRenderTarget(view: UIKit.UIView)
  public func removeRenderTarget()
  public func toggleBeautification() -> Swift.Bool
  public func discardAppliedChanges()
  public func configurePhotoModeIfNeeded(isFrontCamera: Swift.Bool, isEnableTorch: Swift.Bool)
  public func makeCameraPhoto(cameraSettings: CameraModulePhotoSettings, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  public func getRendererView() -> UIKit.UIView
  public func setText(_ text: Swift.String, color: UIKit.UIColor, area: EffectTextAreaConfig)
  public func replaceCamera(_ camera: CameraModule, completion: (() -> Swift.Void)?)
  public func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
  @objc deinit
}
extension SDKService : SDKMaskPostprocessServicing {
  public func postprocessProcessVideoFrame(_ from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, time: CoreMedia.CMTime)
  public func postprocessStopVideoProcessing()
  public func postprocessPlaybackStop()
  public func postprocessSurfaceDestroyed()
  public func postprocessSurfaceCreated(with size: CoreGraphics.CGSize)
  public func postprocessSetEffectSize(_ size: CoreGraphics.CGSize)
  public func postprocessLoadEffect(path: Swift.String)
  public func postprocessStartVideoProcessing(with size: CoreGraphics.CGSize)
  public func postprocessDraw()
}
public protocol CountdownTimerViewFactory {
  func makeCountdownTimerView() -> CountdownTimerAnimatableView
}
public struct ColorPair : Swift.Equatable {
  public let background: UIKit.UIColor
  public let foreground: UIKit.UIColor
  public init(background: UIKit.UIColor, foreground: UIKit.UIColor)
  public static func == (a: ColorPair, b: ColorPair) -> Swift.Bool
}
public struct VideoTextColorPair : Swift.Equatable {
  public let foreground: ColorPair
  public let background: ColorPair
  public init(colors: (UIKit.UIColor, UIKit.UIColor, UIKit.UIColor, UIKit.UIColor))
  public init(foreground: ColorPair, background: ColorPair)
  public static func == (lhs: VideoTextColorPair, rhs: VideoTextColorPair) -> Swift.Bool
}
public struct VideoTextFont {
  public var font: UIKit.UIFont?
  public var name: Swift.String
  public init(font: UIKit.UIFont?, name: Swift.String)
}
public struct GiphyImage {
  public let id: Swift.String
  public let url: Foundation.URL
  public let width: Swift.Int
  public let height: Swift.Int
}
public enum DeviceModel : Swift.String {
  case simulator, iPod1, iPod2, iPod3, iPod4, iPod5, iPad2, iPad3, iPad4, iPhone4, iPhone4S, iPhone5, iPhone5S, iPhone5C, iPadMini1, iPadMini2, iPadMini3, iPadAir1, iPadAir2, iPadPro9_7, iPadPro9_7_cell, iPadPro10_5, iPadPro10_5_cell, iPadPro12_9, iPadPro12_9_cell, iPhone6, iPhone6plus, iPhone6S, iPhone6Splus, iPhoneSE, iPhone7, iPhone7plus, iPhone8, iPhone8plus, iPhoneX, iPhoneXS, iPhoneXSmax, iPhoneXR, iPhone11, iPhone11Pro, iPhone11ProMax, unrecognized
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension UIDevice {
  public var type: DeviceModel {
    get
  }
}
@frozen public enum CameraModuleSessionType {
  case frontVideo
  case backVideo
  case frontPhoto
  case backPhoto
  public static func == (a: CameraModuleSessionType, b: CameraModuleSessionType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct CameraModulePhotoSettings {
  public let useStabilization: Swift.Bool
  public let flashMode: AVFoundation.AVCaptureDevice.FlashMode
  public init(useStabilization: Swift.Bool, flashMode: AVFoundation.AVCaptureDevice.FlashMode)
}
public struct CameraModuleDefaults {
  public static var viewSize: CoreGraphics.CGSize {
    get
  }
}
public protocol CameraModule : SDKBeautyEffectManaging, SDKEffectsServicing, SDKInputServicing, SDKMaskPostprocessServicing, SDKOutputServicing {
  var isLoaded: Swift.Bool { get }
  var isStarted: Swift.Bool { get }
  var allowProcessing: Swift.Bool { get set }
  var playerViewSize: CoreGraphics.CGSize { get }
  var autoStart: Swift.Bool { get set }
  func setup(postproccessContext: OpenGLES.EAGLContext)
  func destroy()
  func start(completion: @escaping () -> Swift.Void)
  func stop(completion: (() -> Swift.Void)?)
  func setRenderTarget(view: UIKit.UIView)
  func removeRenderTarget()
  func takeSnapshot(handler: @escaping (UIKit.UIImage) -> Swift.Void)
  func makeCameraPhoto(cameraSettings: CameraModulePhotoSettings, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  func getRendererView() -> UIKit.UIView
}
@objc @_inheritsConvenienceInitializers public class GIFPickerDataLoadingViewController : UIKit.UIViewController {
  public var loadingIndicator: VideoEditorActivityIndicator?
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  public func startAnimating()
  public func stopAnimating()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol TimelineAdoptable : AnyObject {
  var timelineDataSource: TimelineDataSource? { get set }
}
public class TextEditSelectionBorderRoundingBehavior : TextEditSelectionColorBehavior {
  final public let selectionLineWidth: CoreGraphics.CGFloat
  final public let selectionLineColor: UIKit.UIColor
  final public let selectionLinePadding: CoreGraphics.CGFloat
  required public init(selectionLineWidth: CoreGraphics.CGFloat, selectionLineColor: UIKit.UIColor, selectionLinePadding: CoreGraphics.CGFloat)
  public func setColorView(_ colorView: UIKit.UIView, selected: Swift.Bool, animated: Swift.Bool)
  @objc deinit
}
extension UIColor {
  convenience public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int, a: CoreGraphics.CGFloat = 1.0)
  convenience public init(rgb: Swift.Int, a: CoreGraphics.CGFloat = 1.0)
}
public class VideoEditorEffectDrawer : CompositionRenderering {
  public var renderer: EffectRenderer? {
    get
  }
  required public init()
  public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, allSources: [CoreVideo.CVPixelBuffer], sampleTime: CoreMedia.CMTime, effect: EditorCompositionEffectProtocol)
  @objc deinit
}
public enum CameraNotificationType {
  case firstPartNotRecorded
  case secondPartIsTooShort
  case videoIsTooShort
  case flashlightOn
  case beautifyerOn
  case activateTimer(duration: Swift.Int, activate: Swift.Bool)
  case galleryReceiveFromiCloud
  case galleryReceiveError(Swift.Error)
  case tapOnMask
  case maskNotLoaded
  public var message: Swift.String {
    get
  }
}
public struct VideoEditorConfig {
  public var videoResolutionConfiguration: VideoResolutionConfiguration
  public var recorderConfiguration: RecorderConfiguration
  public var editorConfiguration: EditorConfiguration
  public var singleTrimConfiguration: SingleTrimConfiguration
  public var textEditorConfiguration: TextEditorConfiguration
  public var toastConfiguration: ToastConfiguration
  public var fullScreenActivityConfiguration: FullScreenActivityConfiguration
  public var smallActivityIndicatorConfiguration: SmallActivityIndicatorConfiguration
  public var albumsConfiguration: AlbumsConfiguration
  public var videoOverlayConfiguration: VideoOverlayConfiguration
  public var videoDurationConfiguration: VideoEditorDurationConfig
  public var gifPickerConfiguration: GifPickerConfiguration
  public var slideShowConfiguration: SlideShowConfiguration
  public var combinedGalleryConfiguration: CombinedGalleryConfiguration?
  public var trimTimeLineConfiguration: TrimTimeLineConfiguration?
  public var galleryConfiguration: GalleryConfiguration
  public var trimGalleryVideoConfiguration: TrimGalleryVideoConfiguration
  public var filterConfiguration: FilterConfiguration
  public var videoCoverSelectionConfiguration: VideoCoverSelectionConfiguration
  public var musicEditorConfiguration: MusicEditorConfig
  public var overlayEditorConfiguration: OverlayEditorConfiguration
  public var multiTrimConfiguration: MultiTrimConfiguration
  public var watermarkConfiguration: WatermarkConfiguration?
  public var speedSelectionConfiguration: SpeedSelectionConfiguration
  public var alertViewConfiguration: AlertViewConfiguration
  public var featureConfiguration: FeatureConfiguration
  public init()
  public init(videoResolutionConfiguration: VideoResolutionConfiguration, recorderConfiguration: RecorderConfiguration, editorConfiguration: EditorConfiguration, singleTrimConfiguration: SingleTrimConfiguration, textEditorConfiguration: TextEditorConfiguration, toastConfiguration: ToastConfiguration, fullScreenActivityConfiguration: FullScreenActivityConfiguration, smallActivityIndicatorConfiguration: SmallActivityIndicatorConfiguration, albumsConfiguration: AlbumsConfiguration, videoOverlayConfiguration: VideoOverlayConfiguration, videoDurationConfiguration: VideoEditorDurationConfig, gifPickerConfiguration: GifPickerConfiguration, slideShowConfiguration: SlideShowConfiguration, trimTimeLineConfiguration: TrimTimeLineConfiguration, combinedGalleryConfiguration: CombinedGalleryConfiguration?, galleryConfiguration: GalleryConfiguration, trimGalleryVideoConfiguration: TrimGalleryVideoConfiguration, filterConfiguration: FilterConfiguration, videoCoverSelectionConfiguration: VideoCoverSelectionConfiguration, musicEditorConfiguration: MusicEditorConfig, overlayEditorConfiguration: OverlayEditorConfiguration, featureConfiguration: FeatureConfiguration, multiTrimConfiguration: MultiTrimConfiguration, watermarkConfiguration: WatermarkConfiguration?, speedSelectionConfiguration: SpeedSelectionConfiguration, alertViewConfiguration: AlertViewConfiguration)
  public mutating func applyFont(_ font: UIKit.UIFont)
  public mutating func updateAlertFonts(_ font: UIKit.UIFont)
  public mutating func updateRecorderFonts(_ font: UIKit.UIFont)
  public mutating func updateMultiTrimFonts(_ font: UIKit.UIFont)
  public mutating func updateCombinedGalleryFonts(_ font: UIKit.UIFont)
  public mutating func updateEditorFonts(_ font: UIKit.UIFont)
  public mutating func updateSingleTrimFonts(_ font: UIKit.UIFont)
  public mutating func updateToastFonts(_ font: UIKit.UIFont)
  public mutating func updateFullScreenActivityFonts(_ font: UIKit.UIFont)
  public mutating func updateAlbumsFonts(_ font: UIKit.UIFont)
  public mutating func updateTextEditorFonts(_ font: UIKit.UIFont)
  public mutating func updateSlideShowFonts(_ font: UIKit.UIFont)
  public mutating func updateGalleryFonts(_ font: UIKit.UIFont)
  public mutating func updateTrimGalleryVideoFonts(_ font: UIKit.UIFont)
  public mutating func updateFilterFonts(_ font: UIKit.UIFont)
  public mutating func updateVideoCoverSelectionFonts(_ font: UIKit.UIFont)
  public mutating func updateFeatureConfiguration(featureConfiguration: FeatureConfiguration)
}
public struct VideoEditorDurationConfig {
  public var maximumVideoDuration: Foundation.TimeInterval
  public var minimumDurationFromCamera: Foundation.TimeInterval
  public var minimumDurationFromGallery: Foundation.TimeInterval
  public var minimumVideoDuration: Foundation.TimeInterval
  public var minimumTrimmedPartDuration: Foundation.TimeInterval
  public var minimumRecordingTimeToPlayCountdownAnimation: Foundation.TimeInterval
  public init(maximumVideoDuration: Foundation.TimeInterval = 60.0, minimumDurationFromCamera: Foundation.TimeInterval = 3.0, minimumDurationFromGallery: Foundation.TimeInterval = 3.0, minimumVideoDuration: Foundation.TimeInterval = 3.0, minimumTrimmedPartDuration: Foundation.TimeInterval = 2.0, minimumRecordingTimeToPlayCountdownAnimation: Foundation.TimeInterval = 10.0)
}
public struct TextEditorConfiguration {
  public var doneButton: RoundedButtonConfiguration
  public var fontButton: RoundedButtonConfiguration
  public var textBackgroundButton: ImageButtonConfiguration
  public var alignmentImages: [VideoTextAligment : ImageButtonConfiguration]
  public var palette: [VideoTextColorPair]
  public var fonts: [VideoTextFont]
  public var backgroundConfiguration: BackgroundConfiguration
  public var screenNameConfiguration: ScreenNameConfiguration
  public var palleteInsets: UIKit.UIEdgeInsets
  public var selectionColorBehavior: TextEditSelectionColorBehavior
  public var colorItemConfiguration: TextEditColorItemConfiguration
}
public struct TextEditColorItemConfiguration {
  public var borderColor: UIKit.UIColor
  public var borderWidth: CoreGraphics.CGFloat
  public init(borderColor: UIKit.UIColor, borderWidth: CoreGraphics.CGFloat)
}
public struct VideoOverlayConfiguration {
  public var deleteImageConfiguration: ImageConfiguration
}
public struct FullScreenActivityConfiguration {
  public var labelFont: UIKit.UIFont
  public var cornerRadius: CoreGraphics.CGFloat
  public var activityEffectsViewAlpha: CoreGraphics.CGFloat
  public var activityIndicator: SmallActivityIndicatorConfiguration
  public init(labelFont: UIKit.UIFont, cornerRadius: CoreGraphics.CGFloat, activityEffectsViewAlpha: CoreGraphics.CGFloat, activityIndicator: SmallActivityIndicatorConfiguration)
}
public struct RecorderConfiguration {
  public var videoResolution: VideoResolutionConfiguration
  public var saveButton: SaveButtonConfiguration?
  public var backButton: BackButtonConfiguration
  public var removeButtonImageName: Swift.String
  public var captureButtonMode: CaptureButtonMode
  public var recordButtonConfiguration: RecordButtonConfiguration
  public var recordButtonProvider: VideoEditorCaptureButtonProvider?
  public var additionalEffectsButtons: [AdditionalEffectsButtonConfiguration]
  public var speedButton: SpeedButtonConfiguration
  public var galleryButton: RoundedButtonConfiguration
  public var emptyGalleryImageName: Swift.String
  public var timerConfiguration: TimerConfiguration
  public var timeLineConfiguration: TimeLineConfiguration
  public var scrollBarConfiguration: ScrollBarConfiguration
  public var regularRecordButtonPosition: CoreGraphics.CGFloat
  public var recorderEffectsConfiguration: RecorderEffectsConfiguration
  public var leftControlsBottomOffsetFromCaptureButton: CoreGraphics.CGFloat
  public var leftControlsLeftOffset: CoreGraphics.CGFloat
  public var sequenceHeight: CoreGraphics.CGFloat
  public var useHorizontalVersion: Swift.Bool
  public var loopAudioWhileRecording: Swift.Bool
  public var takeAudioDurationAsMaximum: Swift.Bool
  public var isDynamicMusicTitle: Swift.Bool
}
public struct RecordButtonConfiguration {
  public var idleStrokeColor: CoreGraphics.CGColor
  public var strokeColor: CoreGraphics.CGColor
  public var gradientColors: [CoreGraphics.CGColor]
  public var circularTimeLineIdleWidth: CoreGraphics.CGFloat
  public var circularTimeLineCaptureWidth: CoreGraphics.CGFloat
  public var normalImageName: Swift.String
  public var recordImageName: Swift.String
  public var width: CoreGraphics.CGFloat
  public var height: CoreGraphics.CGFloat
  public var recordingScale: CoreGraphics.CGFloat
}
public struct SingleTrimConfiguration {
  public var saveButton: SaveButtonConfiguration
  public var backButton: BackButtonConfiguration
  public var throbber: SmallActivityIndicatorConfiguration
  public var trimTimeLineConfiguration: TrimTimeLineConfiguration
  public var trimTimeLineHeight: CoreGraphics.CGFloat
  public var playerControlConfiguration: PlayerControlConfiguration
  public var backgroundConfiguration: BackgroundConfiguration
  public var screenNameConfiguration: ScreenNameConfiguration
  public var editedTimeLabelConfiguration: TimeLabelConfiguration
}
public struct MultiTrimConfiguration {
  public var saveButton: SaveButtonConfiguration
  public var backButton: BackButtonConfiguration
  public var timeLimeConfiguration: TimeLineConfiguration
  public var trimTimeLineConfiguration: TrimTimeLineConfiguration
  public var trimTimeLineHeight: CoreGraphics.CGFloat
  public var playerControlConfiguration: PlayerControlConfiguration
  public var backgroundConfiguration: BackgroundConfiguration
  public var bottomViewBackgroundConfiguration: BackgroundConfiguration
  public var screenNameConfiguration: ScreenNameConfiguration
  public var trimSequenceEdgeInsets: UIKit.UIEdgeInsets
  public var trimSequenceHeight: CoreGraphics.CGFloat
  public var editedTimeLabelConfiguration: TimeLabelConfiguration
}
public struct TimeLineConfiguration {
  public var isTimeLineHidden: Swift.Bool
  public var timeLineBackgroundColor: UIKit.UIColor
  public var progressBarColor: UIKit.UIColor
  public var progressBarSelectColor: UIKit.UIColor
  public var itemsCornerRadius: CoreGraphics.CGFloat
  public var separatorWidth: CoreGraphics.CGFloat
  public var separatorColor: UIKit.UIColor
}
public struct ScrollBarConfiguration {
  public var isScrollBarShoudDisplay: Swift.Bool
  public var normalLabelFont: UIKit.UIFont
  public var slideshowLabelFont: UIKit.UIFont
}
public struct TrimTimeLineConfiguration {
  public var maxColor: UIKit.UIColor
  public var defaultColor: UIKit.UIColor
  public var trimControlsColor: UIKit.UIColor
  public var cursorColor: UIKit.UIColor
  public var draggersLineColor: UIKit.UIColor
  public var draggersCornerRadius: CoreGraphics.CGFloat
  public var draggersLineWidth: CoreGraphics.CGFloat
  public var draggersLineHeight: CoreGraphics.CGFloat
  public var numberOfLinesInDraggers: Swift.Int
  public var draggerLinesSpacing: CoreGraphics.CGFloat
  public var borderWidth: CoreGraphics.CGFloat
  public var draggersLineCornerRadius: CoreGraphics.CGFloat
  public var cancelButtonConfiguration: TextButtonConfiguration
  public var doneButtonConfiguration: TextButtonConfiguration
  public var draggerImageName: Swift.String?
  public var draggerWidth: CoreGraphics.CGFloat
  public var timelineTopBottomInset: CoreGraphics.CGFloat
  public var videoResolution: VideoResolutionConfiguration
}
public struct EditorConfiguration {
  public var additionalEffectsButtons: [AdditionalEffectsButtonConfiguration]
  public var additionalEffectsButtonsBottomOffset: CoreGraphics.CGFloat
  public var videoResolution: VideoResolutionConfiguration
  public var saveButton: BanubaButtonConfiguration
  public var backButton: BackButtonConfiguration
  public var isVideoCoverSelectionEnabled: Swift.Bool
  public var useHorizontalVersion: Swift.Bool
  public var playButtonImageName: Swift.String
}
public struct CombinedGalleryConfiguration {
  public var videoResolution: VideoResolutionConfiguration
  public var textButton: TextButtonConfiguration
  public var backButton: BackButtonConfiguration
  public var layoutConfiguration: GalleryLayoutConfiguration
}
public struct AlbumsConfiguration {
  public var textButton: TextButtonConfiguration
  public var backButton: BackButtonConfiguration
}
public struct SlideShowConfiguration {
  public var videoResolution: VideoResolutionConfiguration
  public var galleryItemConfiguration: GalleryItemConfiguration
  public var closeButtonConfiguration: ImageButtonConfiguration
  public var albumButtonConfiguration: TextButtonConfiguration
  public var nextButtonConfiguration: SaveButtonConfiguration
  public var noPhotosLabelConfiguration: TextConfiguration
  public var layoutConfiguration: GalleryLayoutConfiguration
  public var topBarBlurColor: UIKit.UIColor
  public var clearSelectionButtonConfiguration: ImageButtonConfiguration
}
public struct GifPickerConfiguration {
  public var regularFont: UIKit.UIFont
  public var boldFont: UIKit.UIFont
  public var activityConfiguration: SmallActivityIndicatorConfiguration
  public var cursorColor: UIKit.UIColor
  public var giphyAPIKey: Swift.String?
}
public struct GalleryItemConfiguration {
  public var orderNumberBackgroudColor: UIKit.UIColor
  public var orderNumberTitleColor: UIKit.UIColor
  public var backgroundSelectionIndicatorImageName: Swift.String
  public var hideSelectionIndicatorBySelection: Swift.Bool
  public var durationLabelConfiguration: TextConfiguration
  public var durationLabelBackgroundColor: UIKit.UIColor
  public var activityIndicatorConfiguration: SmallActivityIndicatorConfiguration
  public var cornerRadius: CoreGraphics.CGFloat
}
public struct GalleryConfiguration {
  public var backButtonConfiguration: BackButtonConfiguration
  public var titleConfiguration: TextConfiguration
  public var noVideoFoundTitleConfiguration: TextConfiguration
  public var noVideoFoundSubtitleConfiguration: TextConfiguration
  public var multiselectButtonConfiguration: ImageButtonConfiguration
  public var cancelMultiselectButtonConfiguration: ImageButtonConfiguration
  public var chooseSelectionButtonConfiguration: SaveButtonConfiguration
  public var galleryItemConfiguration: GalleryItemConfiguration
  public var layoutConfiguration: GalleryLayoutConfiguration
}
public struct GalleryLayoutConfiguration {
  public var numberOfItemsPerRow: Swift.Int
  public var interitemSpacing: CoreGraphics.CGFloat
  public var edgeInsets: UIKit.UIEdgeInsets
}
public struct AlertViewConfiguration {
  public var cornerRadius: CoreGraphics.CGFloat
  public var buttonRadius: CoreGraphics.CGFloat
  public var refuseButtonBackgroundColor: UIKit.UIColor
  public var refuseButtonTextColor: UIKit.UIColor
  public var agreeButtonBackgroundColor: UIKit.UIColor
  public var agreedButtonTextColor: UIKit.UIColor
  public var titleAligment: UIKit.NSTextAlignment
  public var titleFont: UIKit.UIFont
  public var buttonsFont: UIKit.UIFont
}
public struct TrimGalleryVideoConfiguration {
  public var videoResolutionConfiguration: VideoResolutionConfiguration
  public var activityIndicatorConfiguration: SmallActivityIndicatorConfiguration
  public var deleteGalleryVideoPartButtonConfiguration: ImageButtonConfiguration
  public var galleryVideoPartsConfiguration: GalleryVideoPartsConfiguration
  public var backButtonConfiguration: BackButtonConfiguration
  public var nextButtonConfiguration: SaveButtonConfiguration
  public var deleteToolTipLabel: TextConfiguration
  public var playerControlConfiguration: PlayerControlConfiguration
  public var videoPartsBackgroundConfiguration: BackgroundConfiguration
  public var backgroundConfiguration: BackgroundConfiguration
  public var screenNameConfiguration: ScreenNameConfiguration
  public var editedTimeLabelConfiguration: TimeLabelConfiguration
}
public struct FilterConfiguration {
  public var cancelButton: RoundedButtonConfiguration
  public var doneButton: RoundedButtonConfiguration
  public var resetButton: RoundedButtonConfiguration
  public var toolTipLabel: TextConfiguration
  public var cursorButton: ImageButtonConfiguration
  public var backgroundConfiguration: BackgroundConfiguration
  public var timelineCornerRadius: CoreGraphics.CGFloat
  public var effectItemConfiguration: EffectItemConfiguration
  public var doneButtonHeight: CoreGraphics.CGFloat?
  public var timelineHeight: CoreGraphics.CGFloat
  public var timelineLeftOffset: CoreGraphics.CGFloat
  public var timelineRightOffset: CoreGraphics.CGFloat
  public var filtersHeight: CoreGraphics.CGFloat
  public var screenNameConfiguration: ScreenNameConfiguration
}
public struct VideoCoverSelectionConfiguration {
  public var cancelButton: TextButtonConfiguration
  public var doneButton: RoundedButtonConfiguration
  public var toolTipLabel: TextConfiguration
  public var sliderColor: UIKit.UIColor
  public var sliderMinTrackTintColor: UIKit.UIColor
  public var sliderMaxTrackTintColor: UIKit.UIColor
  public var backgroundConfiguration: BackgroundConfiguration
}
public protocol MusicSelectorViewControllerDelegate : ScrollBarManagerProviding {
  func didSelectFile(at url: Foundation.URL, title: Swift.String, id: Swift.Int64)
  func didClearSelection()
  func didCancel()
}
public protocol MusicSelectorViewController : UIKit.UIViewController {
  var delegate: MusicSelectorViewControllerDelegate? { get set }
}
public protocol ExternalViewControllerFactory {
  var musicEditorFactory: MusicEditorExternalViewControllerFactory? { get set }
  var countdownTimerViewFactory: CountdownTimerViewFactory? { get set }
  var exposureViewFactory: AnimatableViewFactory? { get set }
}
extension UIImage {
  public static func findConfigurationImage(named: Swift.String) -> UIKit.UIImage?
}
public typealias AVAssetExportPreset = Swift.String
public enum ExportQuality {
  case preset(AVAssetExportPreset)
  case videoConfiguration(ExportVideoInfo)
  case auto
}
public struct ExportVideoConfiguration {
  public let fileURL: Foundation.URL
  public let quality: ExportQuality
  public let watermarkConfiguration: WatermarkConfiguration?
  public init(fileURL: Foundation.URL, quality: ExportQuality, watermarkConfiguration: WatermarkConfiguration?)
}
public struct RecorderAnalytics {
  public enum EventKind : Swift.String, AnalyticsEventKind {
    public static let domain: Swift.String
    case toggleFlash
    case changeSpeed
    case toggleCamera
    case toggleTimer
    case addFilter
    case addMask
    case changeMaskSubtype
    case toggleBeautification
    case presentMusicPicker
    case presentMaskPicker
    case presentFilterPicker
    case recordVideoPart
    case removeVideoPart
    case done
    public var parameterKeys: [RecorderAnalytics.ParameterKey]? {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public typealias ParameterKey = RecorderAnalytics.ParameterKey
  }
  public enum ParameterKey : Swift.String, AnalyticsParameterKey {
    case isFlashOn
    case recordSpeed
    case cameraType
    case timerDuration
    case filterID
    case maskID
    case musicID
    case maskSubtypeID
    case isBeautificationOn
    case recordingGesture
    case videoPartDuration
    case videoPartInfos
    case videoPartCount
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias Manager = AnalyticsManager<RecorderAnalytics.EventKind>
}
public struct AnalyticsDefaults {
  public static let recorderScreenName: Swift.String
  public static let editorScreenName: Swift.String
  public static let tapGestureName: Swift.String
  public static let longTapGestureName: Swift.String
  public static let colorEffectTypeName: Swift.String
  public static let visualEffectTypeName: Swift.String
  public static let timeEffectTypeName: Swift.String
}
public struct VideoDurationDefaults {
  public static var shared: VideoEditorDurationConfig
}
public struct VideoImportDefaults {
  public static let maximumNumberOfVideos: Swift.Int
}
public struct VideoAspectRatio {
  public static var minFillAspectRatio: CoreGraphics.CGFloat {
    get
  }
  public static var maxFillAspectRatio: CoreGraphics.CGFloat {
    get
  }
  public static var fillAspectRatioRange: Swift.ClosedRange<CoreGraphics.CGFloat> {
    get
  }
}
public protocol TimelineViewControllerDelegate : AnyObject {
  func changeVideoPosition(on time: CoreMedia.CMTime)
  func shouldPauseVideo()
}
@_hasMissingDesignatedInitializers public class EffectInterval {
  public struct IntervalRange {
    public var location: Foundation.TimeInterval
    public var length: Foundation.TimeInterval
  }
  public var range: EffectInterval.IntervalRange
  @objc deinit
}
@objc public class TimelineViewController : UIKit.UIViewController, TimelineAdoptable {
  public var cursorConfiguration: ImageButtonConfiguration?
  public var effectIntervals: [EffectInterval] {
    get
    set
  }
  public var currentInterval: EffectInterval?
  public var timelineDataSource: TimelineDataSource?
  weak public var delegate: TimelineViewControllerDelegate?
  public func setAppliedEffects(_ effects: [EditorCompositionEffectProtocol])
  @objc dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewDidLayoutSubviews()
  public func setTimelineTime(time: CoreMedia.CMTime)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension TimelineViewController {
  public func startInterval(at startTime: Foundation.TimeInterval, color: UIKit.UIColor, name: Swift.String?)
  public func endInterval(at endTime: Foundation.TimeInterval)
}
extension TimelineViewController : TimelineDataSourceDelegate {
  public func didLoadImage(_ image: UIKit.UIImage, at index: Swift.Int)
  public func didFinishThumbnailFetch()
}
public protocol EffectConfigProtocol : AnyObject {
  var areas: [EffectTextAreaConfig]? { get }
  func hasTextAreas() -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class PreviewVideoView : UIKit.UIImageView {
  @objc override dynamic public class var layerClass: Swift.AnyClass {
    @objc get
  }
  public func previewLayer() -> AVFoundation.AVPlayerLayer
  public func setPlayer(_ player: AVFoundation.AVPlayer?, isThumbnailNeeded: Swift.Bool)
  @objc deinit
  @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol VideoMetadataStorageDelegate : AnyObject {
  func videoMetadataStorageDidStartStoring(_ videoMetadataStorage: VideoMetadataStoring)
}
public protocol VideoMetadataStoring {
  var colorOnVideoMetadata: ColorOnVideoMetadata? { get }
  var videoEditorMetadata: VideoEditorMetadata? { get }
  var videoMetadata: VideoMetadata? { get }
  var videoEditorTrimMetadata: VideoEditorTrimMetadata? { get }
  var audioTracks: [AudioTrackAdoptable]? { get }
  var videoCoverIndentMetadata: TimeMetadata? { get }
  var musicEditorMetadata: MusicEditorMetadata? { get }
  var effectsOnVideoMetadata: [EffectOnVideoMetadata]? { get }
  var delegate: VideoMetadataStorageDelegate? { get set }
  func reset()
  func update(metadata: [EffectOnVideoMetadata])
  func update(metadata: [AudioTrackAdoptable])
  func update(metadata: VideoEditorTrimMetadata)
  func update(metadata: VideoEditorMetadata)
  func update(metadata: VideoMetadata)
  func update(metadata: ColorOnVideoMetadata)
  func update(metadata: TimeMetadata)
}
@_hasMissingDesignatedInitializers public class VideoMetadataStorage : VideoMetadataStoring {
  public var videoMetadata: VideoMetadata? {
    get
  }
  public var colorOnVideoMetadata: ColorOnVideoMetadata? {
    get
  }
  public var effectsOnVideoMetadata: [EffectOnVideoMetadata]? {
    get
  }
  public var videoEditorMetadata: VideoEditorMetadata? {
    get
  }
  public var videoEditorTrimMetadata: VideoEditorTrimMetadata? {
    get
  }
  public var audioTracks: [AudioTrackAdoptable]? {
    get
  }
  public var videoCoverIndentMetadata: TimeMetadata? {
    get
  }
  public var musicEditorMetadata: MusicEditorMetadata? {
    get
  }
  weak public var delegate: VideoMetadataStorageDelegate?
  public func update(metadata: [AudioTrackAdoptable])
  public func update(metadata: VideoEditorTrimMetadata)
  public func update(metadata: ColorOnVideoMetadata)
  public func update(metadata: [EffectOnVideoMetadata])
  public func update(metadata: VideoMetadata)
  public func update(metadata: VideoEditorMetadata)
  public func update(metadata: TimeMetadata)
  public func reset()
  @objc deinit
}
public struct ImageCroppingInfo {
  public var croppingRect: CoreGraphics.CGRect
  public var imageSize: CoreGraphics.CGSize
}
extension UIViewController {
  public func ext_addChildViewController(_ viewController: UIKit.UIViewController, toView: UIKit.UIView, addConstraints: Swift.Bool = true)
}
public enum RecordMode : Swift.Int {
  case mixed
  case normal
  case photo
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol RecorderPresenterProtocol : AnyObject {
  func changeViewToIdleState()
  func changeViewToCaptureState()
  func updateCaptureProgress(_ progress: Swift.Double)
  func presentCountdownAnimations(with timeout: Foundation.TimeInterval, completion: @escaping (Swift.Bool) -> ())
  func dismissCountdownAnimations()
  func sequenceViewRemoveLast()
  func presentAlertAboutLowDiskSpace()
  func captureSessionDidEnd()
  func presentMessage(with text: Swift.String)
  func didStartExportPhoto()
  func didEndExportPhoto()
  func didUpdateVideoSequence()
}
public protocol SDKOutputServicing : AnyObject {
  var isRecording: Swift.Bool { get }
  var isEnoughDiskSpaceForRecording: Swift.Bool { get }
  func startVideoCapturing(fileURL: Foundation.URL?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  func startVideoCapturing(fileURL: Foundation.URL?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, periodicProgressTimeInterval: Foundation.TimeInterval, boundaryTimes: [Foundation.NSValue], boundaryHandler: @escaping (CoreMedia.CMTime) -> Swift.Void, totalDuration: Foundation.TimeInterval, completion: @escaping (Swift.Bool, Swift.Error?) -> Swift.Void)
  func stopVideoCapturing(cancel: Swift.Bool)
}
public struct TextConfiguration {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var color: UIKit.UIColor
  public var alignment: UIKit.NSTextAlignment
  public init(kern: Swift.Double = 0, font: UIKit.UIFont, color: UIKit.UIColor, alignment: UIKit.NSTextAlignment = .center)
}
public struct ImageConfiguration {
  public var imageName: Swift.String
  public var image: UIKit.UIImage? {
    get
  }
  public init(imageName: Swift.String)
  public init(image: UIKit.UIImage)
}
public struct ImageButtonConfiguration {
  public var imageConfiguration: ImageConfiguration
  public var selectedImageConfiguration: ImageConfiguration?
  public init(imageConfiguration: ImageConfiguration, selectedImageConfiguration: ImageConfiguration? = nil)
}
public struct RoundedButtonConfiguration {
  public var textConfiguration: TextConfiguration
  public var borderWidth: CoreGraphics.CGFloat?
  public var borderColor: CoreGraphics.CGColor?
  public var cornerRadius: CoreGraphics.CGFloat
  public var backgroundColor: UIKit.UIColor
  public init(textConfiguration: TextConfiguration, cornerRadius: CoreGraphics.CGFloat, backgroundColor: UIKit.UIColor, borderWidth: CoreGraphics.CGFloat? = nil, borderColor: CoreGraphics.CGColor? = nil)
}
public struct TextButtonConfiguration {
  public var style: TextConfiguration
  public var text: Swift.String?
  public init(style: TextConfiguration, text: Swift.String? = nil)
}
public struct SaveButtonConfiguration {
  public var textConfiguration: TextConfiguration
  public var inactiveTextConfiguration: TextConfiguration
  public var text: Swift.String
  public var width: CoreGraphics.CGFloat
  public var height: CoreGraphics.CGFloat
  public var cornerRadius: CoreGraphics.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var inactiveBackgroundColor: UIKit.UIColor
  public init(textConfiguration: TextConfiguration, inactiveTextConfiguration: TextConfiguration, text: Swift.String, width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, cornerRadius: CoreGraphics.CGFloat, backgroundColor: UIKit.UIColor, inactiveBackgroundColor: UIKit.UIColor)
}
public struct SpeedButtonConfiguration {
  public var imageNameHalf: Swift.String
  public var imageNameNormal: Swift.String
  public var imageNameDouble: Swift.String
  public var imageNameTriple: Swift.String
  public init(imageNameHalf: Swift.String, imageNameNormal: Swift.String, imageNameDouble: Swift.String, imageNameTriple: Swift.String)
}
public struct BackButtonConfiguration {
  public var imageConfiguration: ImageConfiguration
  public var selectedImageConfiguration: ImageConfiguration?
  public var position: BackButtonConfiguration.Position?
  public enum Position {
    case left
    case right
    public static func == (a: BackButtonConfiguration.Position, b: BackButtonConfiguration.Position) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(imageConfiguration: ImageConfiguration, selectedImageConfiguration: ImageConfiguration? = nil, position: BackButtonConfiguration.Position? = nil)
}
public struct ToastConfiguration {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var cornerRadius: CoreGraphics.CGFloat
  public init(kern: Swift.Double, font: UIKit.UIFont, cornerRadius: CoreGraphics.CGFloat)
}
public struct AdditionalEffectsButtonConfiguration {
  public enum Position : Swift.Int {
    case top
    case bottom
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
    public init?(rawValue: Swift.Int)
  }
  public var identifier: AdditionalEffectsButtonConfiguration.ButtonType
  public var imageConfiguration: ImageConfiguration
  public var selectedImageConfiguration: ImageConfiguration?
  public var title: TextButtonConfiguration?
  public var titlePosition: AdditionalEffectsButtonConfiguration.TitlePosition?
  public var width: CoreGraphics.CGFloat
  public var height: CoreGraphics.CGFloat
  public var position: AdditionalEffectsButtonConfiguration.Position?
  public var imageTitleSpacing: CoreGraphics.CGFloat?
  public var defaultTitleAlpha: CoreGraphics.CGFloat?
  public var selectedTitleAlpha: CoreGraphics.CGFloat?
  public var cornerRadius: CoreGraphics.CGFloat
  public var backgroundColor: UIKit.UIColor
  public init(identifier: AdditionalEffectsButtonConfiguration.ButtonType, imageConfiguration: ImageConfiguration, selectedImageConfiguration: ImageConfiguration?, title: TextButtonConfiguration? = nil, titlePosition: AdditionalEffectsButtonConfiguration.TitlePosition? = nil, width: CoreGraphics.CGFloat = 50, height: CoreGraphics.CGFloat = 50, position: AdditionalEffectsButtonConfiguration.Position? = nil, imageTitleSpacing: CoreGraphics.CGFloat? = nil, defaultTitleAlpha: CoreGraphics.CGFloat? = nil, selectedTitleAlpha: CoreGraphics.CGFloat? = nil, cornerRadius: CoreGraphics.CGFloat = .zero, backgroundColor: UIKit.UIColor = .clear)
  public enum ButtonType : Swift.String {
    case link
    case color
    case sticker
    case text
    case time
    case sound
    case effects
    case toggle
    case flashlight
    case timer
    case speed
    case beauty
    case masks
    case muteSound
    case interactive
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
  }
  public enum TitlePosition {
    case top
    case left
    case right
    case bottom
    public static func == (a: AdditionalEffectsButtonConfiguration.TitlePosition, b: AdditionalEffectsButtonConfiguration.TitlePosition) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public protocol VideoEditorCaptureButtonProvider {
  func getButton(for mode: RecordMode) -> VideoEditorCaptureButton?
}
public struct SmallActivityIndicatorConfiguration {
  public enum GradientType {
    case color(SmallActivityIndicatorConfiguration.GradientColorConfiguration)
    case image(ImageConfiguration)
  }
  public struct GradientColorConfiguration {
    public var angle: CoreGraphics.CGFloat
    public var colors: [CoreGraphics.CGColor]
    public init(angle: CoreGraphics.CGFloat, colors: [CoreGraphics.CGColor])
  }
  public var gradientType: SmallActivityIndicatorConfiguration.GradientType
  public var activityLineWidth: CoreGraphics.CGFloat
  public init(gradientType: SmallActivityIndicatorConfiguration.GradientType, activityLineWidth: CoreGraphics.CGFloat)
}
public struct WatermarkConfiguration {
  public var watermark: ImageConfiguration
  public var size: CoreGraphics.CGSize
  public var sharedOffset: CoreGraphics.CGFloat
  public var position: WatermarkConfiguration.WatermarkPosition
  public enum WatermarkPosition {
    case leftTop
    case leftBottom
    case rightTop
    case rightBottom
    public static func == (a: WatermarkConfiguration.WatermarkPosition, b: WatermarkConfiguration.WatermarkPosition) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(watermark: ImageConfiguration, size: CoreGraphics.CGSize, sharedOffset: CoreGraphics.CGFloat, position: WatermarkConfiguration.WatermarkPosition)
}
public struct FeatureConfiguration {
  public var isMusicEditorEnabled: Swift.Bool
  public var isOverlayEditorEnabled: Swift.Bool
  public var isDoubleTapForToggleCameraEnabled: Swift.Bool
  public var isMuteCameraAudioEnabled: Swift.Bool
  public var isInteractivesEnabled: Swift.Bool
  public static let `default`: FeatureConfiguration
  public init(isMusicEditorEnabled: Swift.Bool, isOverlayEditorEnabled: Swift.Bool, isDoubleTapForToggleCameraEnabled: Swift.Bool, isMuteCameraAudioEnabled: Swift.Bool, isInteractivesEnabled: Swift.Bool)
}
public typealias SpeedBarConfiguration = SpeedSelectionConfiguration.SpeedBarConfiguration
public struct SpeedSelectionConfiguration {
  public var backButton: BackButtonConfiguration
  public var bottomViewBackgroundColor: UIKit.UIColor
  public var bottomViewCornerRadius: CoreGraphics.CGFloat
  public var screenName: TextConfiguration
  public var hideScreenName: Swift.Bool
  public var speedBarConfiguration: SpeedSelectionConfiguration.SpeedBarConfiguration
  public struct SpeedBarConfiguration {
    public var selectorColor: UIKit.UIColor
    public var selectorTextColor: UIKit.UIColor
    public var speedItemBackgroundColor: UIKit.UIColor
    public var speedItemCornerRadius: CoreGraphics.CGFloat
    public var speedItemTextColor: UIKit.UIColor
    public var backgroundColor: UIKit.UIColor
    public var cornerRadius: CoreGraphics.CGFloat
    public var selectorEdgeInsets: UIKit.UIEdgeInsets
    public init(selectorColor: UIKit.UIColor, selectorTextColor: UIKit.UIColor, speedItemBackgroundColor: UIKit.UIColor, speedItemCornerRadius: CoreGraphics.CGFloat, speedItemTextColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, cornerRadius: CoreGraphics.CGFloat, selectorEdgeInsets: UIKit.UIEdgeInsets)
  }
  public init(backButton: BackButtonConfiguration, bottomViewBackgroundColor: UIKit.UIColor, bottomViewCornerRadius: CoreGraphics.CGFloat, screenName: TextConfiguration, hideScreenName: Swift.Bool, speedBarConfiguration: SpeedSelectionConfiguration.SpeedBarConfiguration)
}
public struct RecorderEffectsConfiguration {
  public var cornerRadius: CoreGraphics.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var screenNameConfiguration: ScreenNameConfiguration
  public var effectsHeight: CoreGraphics.CGFloat
  public var effectItemConfiguration: EffectItemConfiguration
  public init(cornerRadius: CoreGraphics.CGFloat, backgroundColor: UIKit.UIColor, screenNameConfiguration: ScreenNameConfiguration, effectsHeight: CoreGraphics.CGFloat, effectItemConfiguration: EffectItemConfiguration)
}
public struct TimerConfiguration {
  public struct TimerOptionConfiguration : Swift.Equatable {
    public var button: ImageButtonConfiguration
    public var startingTimerSeconds: Swift.Int
    public var stoppingTimerSeconds: Swift.Int
    public var description: Swift.String?
    public static func == (lhs: TimerConfiguration.TimerOptionConfiguration, rhs: TimerConfiguration.TimerOptionConfiguration) -> Swift.Bool
    public init(button: ImageButtonConfiguration, startingTimerSeconds: Swift.Int, stoppingTimerSeconds: Swift.Int, description: Swift.String? = nil)
  }
  public var defaultButton: ImageButtonConfiguration
  public var options: [TimerConfiguration.TimerOptionConfiguration]
}
public struct PlayerControlConfiguration {
  public var playButtonImageName: Swift.String
  public var pauseButtonImageName: Swift.String
  public init(playButtonImageName: Swift.String, pauseButtonImageName: Swift.String)
}
public struct ScreenNameConfiguration {
  public var isHidden: Swift.Bool
  public var style: TextConfiguration?
  public init(isHidden: Swift.Bool, style: TextConfiguration? = nil)
}
public struct BackgroundConfiguration {
  public var cornerRadius: CoreGraphics.CGFloat
  public var color: UIKit.UIColor
  public init(cornerRadius: CoreGraphics.CGFloat, color: UIKit.UIColor)
}
public struct GalleryVideoPartsConfiguration {
  public var addGalleryVideoPartImageName: Swift.String
  public var videoPartConfiguration: GalleryVideoPartsConfiguration.GalleryVideoPartConfiguration
  public init(addGalleryVideoPartImageName: Swift.String, videoPartConfiguration: GalleryVideoPartsConfiguration.GalleryVideoPartConfiguration)
  public struct GalleryVideoPartConfiguration {
    public var selectionColor: UIKit.UIColor
    public var durationLabelConfiguration: TextConfiguration
    public var cornerRadius: CoreGraphics.CGFloat
    public var imageCornerRadius: CoreGraphics.CGFloat
    public var imageInsets: UIKit.UIEdgeInsets
    public init(selectionColor: UIKit.UIColor, durationLabelConfiguration: TextConfiguration, cornerRadius: CoreGraphics.CGFloat, imageCornerRadius: CoreGraphics.CGFloat, imageInsets: UIKit.UIEdgeInsets)
  }
}
public struct EffectItemConfiguration {
  public var titleStyle: TextConfiguration
  public var selectionColor: UIKit.UIColor
  public var cornerRadius: CoreGraphics.CGFloat
  public var borderWidth: CoreGraphics.CGFloat
  public var selectWhenHighlight: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var imageInsets: UIKit.UIEdgeInsets
  public var imageCornerRadius: CoreGraphics.CGFloat
  public var alwaysShowTitle: Swift.Bool
  public var showMasksTitle: Swift.Bool
  public init(titleStyle: TextConfiguration, selectionColor: UIKit.UIColor, cornerRadius: CoreGraphics.CGFloat, borderWidth: CoreGraphics.CGFloat, selectWhenHighlight: Swift.Bool, backgroundColor: UIKit.UIColor, imageInsets: UIKit.UIEdgeInsets, imageCornerRadius: CoreGraphics.CGFloat, alwaysShowTitle: Swift.Bool, showMasksTitle: Swift.Bool)
}
public struct BanubaButtonConfiguration {
  public var imageConfiguration: ImageConfiguration?
  public var title: TextButtonConfiguration
  public var width: CoreGraphics.CGFloat
  public var height: CoreGraphics.CGFloat
  public var background: BackgroundConfiguration
  public init(title: TextButtonConfiguration, width: CoreGraphics.CGFloat = 50, height: CoreGraphics.CGFloat = 50, background: BackgroundConfiguration, imageConfiguration: ImageConfiguration? = nil)
}
public struct TimeLabelConfiguration {
  public var textInsets: UIKit.UIEdgeInsets
  public var cornerRadius: CoreGraphics.CGFloat
  public var defaultColor: UIKit.UIColor
  public var errorColor: UIKit.UIColor
  public var style: TextConfiguration
  public init(textInsets: UIKit.UIEdgeInsets, cornerRadius: CoreGraphics.CGFloat, defaultColor: UIKit.UIColor, errorColor: UIKit.UIColor, style: TextConfiguration)
}
extension VideoEditorService : VideoEditorServiceAdoptable {
  public var isMultiAudioEnabled: Swift.Bool {
    get
  }
  public func changeMusicTrackPosition(currentTime: Swift.Double, durationInSeconds: Swift.Double, compositionTimeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack, audioTrack: AudioTrackAdoptable) -> CoreMedia.CMTimeRange?
  public func addMusicTrack(didSelectFile url: Foundation.URL, title: Swift.String, id: Swift.Int64, start: CoreMedia.CMTime, duration: CoreMedia.CMTime?, trimmedStart: Foundation.TimeInterval?) -> (asset: AVFoundation.AVURLAsset, timeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, compositionStart: CoreMedia.CMTime, avAssetTrack: AVFoundation.AVAssetTrack)?
  public func videoTrackVolume() -> Swift.Float
  public func musicTrackVolume(_ track: AudioTrackAdoptable) -> Swift.Float
  public func setVideoTrackVolume(_ volume: Swift.Float, to player: PlayerAdoptable)
  public func setMusicTrackVolume(_ track: AudioTrackAdoptable, volume: Swift.Float, to player: PlayerAdoptable)
  public func removeMusicTrack(_ track: AudioTrackAdoptable) -> Swift.Bool
}
public enum TimeResult {
  case longerThenRequired
  case shorterThenRequired
  case enough
  public static func == (a: TimeResult, b: TimeResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol TimelineDataSourceDelegate : TimelineDataSourceAdoptableDelegate {
  func didFinishThumbnailFetch()
}
public struct DefaultsTimelineThumbnailConfig {
  public static let thumbnailsCount: Swift.Int
  public static let thumbnailHeight: CoreGraphics.CGFloat
}
public protocol TimelineThumbnailConfigurable {
  var thumbnailsCount: Swift.Int { get }
  var thumbnailHeight: CoreGraphics.CGFloat { get }
}
public struct TimelineThumbnailConfig : TimelineThumbnailConfigurable {
  public var thumbnailsCount: Swift.Int
  public var thumbnailHeight: CoreGraphics.CGFloat
  public init(thumbnailsCount: Swift.Int = DefaultsTimelineThumbnailConfig.thumbnailsCount, thumbnailHeight: CoreGraphics.CGFloat = DefaultsTimelineThumbnailConfig.thumbnailHeight)
}
public class TimelineDataSource : TimelineThumbnailConfigurable, TimeLineDataSourceAdoptable, OverlayEditorTimeLineDataSourceAdoptable {
  weak public var delegate: TimelineDataSourceAdoptableDelegate?
  weak public var overlayEditorDelegate: OverlayEditorTimelineDataSourceAdoptableDelegate?
  public var durationInSeconds: Swift.Double {
    get
  }
  public var thumbnails: [UIKit.UIImage] {
    get
  }
  public var isAllThumbnailsFetched: Swift.Bool {
    get
  }
  public var asset: AVFoundation.AVAsset {
    get
  }
  public var thumbnailsCount: Swift.Int
  public var thumbnailHeight: CoreGraphics.CGFloat
  public init(with asset: AVFoundation.AVAsset, instructions: [AVFoundation.AVVideoCompositionInstructionProtocol]? = nil, config: TimelineThumbnailConfigurable = TimelineThumbnailConfig(), alreadyAvailableThumbnails: [UIKit.UIImage] = [])
  public func loadPreview(completion: @escaping (UIKit.UIImage?) -> Swift.Void, at second: Swift.Double = 0.1)
  public func getImage(at index: Swift.Int) -> UIKit.UIImage?
  @objc deinit
}
public class GifImage {
  final public let image: UIKit.UIImage
  final public let data: Foundation.Data
  public init(image: UIKit.UIImage, data: Foundation.Data)
  @objc deinit
}
public class GIFImageRepository {
  public init(giphyApi: GiphyAPI)
  public func get(by url: Foundation.URL, completion: @escaping (Result<GifImage>) -> Swift.Void)
  @objc deinit
}
public protocol BanubaVideoEditorInteractor {
  associatedtype DelegateType
  var delegate: Self.DelegateType? { get set }
  var sdk: SDKServicing? { get set }
}
extension UIView {
  open class func animateWorkarounding(withDuration duration: Foundation.TimeInterval, animations: @escaping () -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
public protocol ImagesSequence {
  var relativeScreenPoints: ImagePoints { get }
  func getImage(at time: Foundation.TimeInterval) -> CoreGraphics.CGImage
}
public enum EffectType {
  case mask
  case effect
  case videoEditorEffect
  public static func == (a: EffectType, b: EffectType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol EffectsManaging {
  func getEffectsWithType(_ type: EffectType) -> [EffectViewModel]
  func getEditorEffectsWithType(_ type: EditorEffectType) -> [VideoEditorFilterModel]
}
@_hasMissingDesignatedInitializers public class EffectsManager : EffectsManaging {
  public func getEffectsWithType(_ type: EffectType) -> [EffectViewModel]
  public func getEditorEffectsWithType(_ type: EditorEffectType) -> [VideoEditorFilterModel]
  @objc deinit
}
extension UIColor {
  convenience public init?(colorParams: ColorParams)
}
public enum VideoRecordSpeed : Swift.Int, Swift.CaseIterable {
  case half
  case normal
  case double
  case triple
  public var speedValue: Swift.Float {
    get
  }
  public var icon: UIKit.UIImage? {
    get
  }
  public var stringSpeedValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
  public typealias AllCases = [VideoRecordSpeed]
  public static var allCases: [VideoRecordSpeed] {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class SpeedSelectionBar : UIKit.UIView {
  public var selectionHandler: ((VideoRecordSpeed) -> ())?
  public var configuration: SpeedBarConfiguration? {
    get
    set
  }
  public var speed: VideoRecordSpeed {
    get
    set
  }
  @objc override dynamic public func awakeFromNib()
  @objc override dynamic public func draw(_ rect: CoreGraphics.CGRect)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension UIViewController {
  public func openAppSettings()
}
public enum Result<T> {
  case success(T)
  case failure(Swift.Error)
  public func get() throws -> T
  public func map<U>(_ transform: (T) -> U) -> Result<U>
}
public enum SDKInputServiceMode {
  case normal
  case ar
  case scanner
  public static func == (a: SDKInputServiceMode, b: SDKInputServiceMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol SDKInputServicingDelegate {
  func willOutput(pixelBuffer: CoreVideo.CVPixelBuffer)
}
public protocol SDKARInputServicingDelegate {
  func didUpdate(arFrame: ARKit.ARFrame, session: ARKit.ARSession)
  func didAdd(anchors: [ARKit.ARAnchor], session: ARKit.ARSession)
  func didUpdate(anchors: [ARKit.ARAnchor], session: ARKit.ARSession)
  func didRemove(didRemove anchors: [ARKit.ARAnchor], session: ARKit.ARSession)
}
public protocol SDKInputServicing : AnyObject {
  var isFrontCamera: Swift.Bool { get }
  var zoomFactor: Swift.Float { get }
  var currentCameraSessionType: CameraModuleSessionType { get }
  var mode: SDKInputServiceMode { get }
  var inputDelegate: SDKInputServicingDelegate? { get set }
  var inputARDelegate: SDKARInputServicingDelegate? { get set }
  func configureExposureSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  func configureFocusSettings(_ point: CoreGraphics.CGPoint?, useContinuousDetection: Swift.Bool)
  func setZoomFactor(_ zoomFactor: Swift.Float) -> Swift.Float
  func toggleCamera()
  func startCamera()
  func startAudioCapturing()
  func stopAudioCapturing()
  func setCameraSessionType(_ type: CameraModuleSessionType)
  @discardableResult
  func setTorch(mode: AVFoundation.AVCaptureDevice.TorchMode) -> AVFoundation.AVCaptureDevice.TorchMode
  func toggleTorch() -> AVFoundation.AVCaptureDevice.TorchMode
}
public struct ImagePoints {
  public init(leftTop: CoreGraphics.CGPoint, rightTop: CoreGraphics.CGPoint, leftBottom: CoreGraphics.CGPoint, rightBottom: CoreGraphics.CGPoint)
  public var leftTop: CoreGraphics.CGPoint
  public var rightTop: CoreGraphics.CGPoint
  public var leftBottom: CoreGraphics.CGPoint
  public var rightBottom: CoreGraphics.CGPoint
  public func applying(_ t: CoreGraphics.CGAffineTransform) -> ImagePoints
}
public class ImageEffectInfo {
  final public let image: CoreGraphics.CGImage
  final public let imagePoints: ImagePoints
  public init(image: CoreGraphics.CGImage, imagePoints: ImagePoints)
  @objc deinit
}
public struct TrimAnalytics {
  public enum EventKind : Swift.String, AnalyticsEventKind {
    public static let domain: Swift.String
    case addVideo
    case moveVideo
    case changePartDuration
    case removeVideoPart
    case done
    public var parameterKeys: [TrimAnalytics.ParameterKey]? {
      get
    }
    public typealias ParameterKey = TrimAnalytics.ParameterKey
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ParameterKey : Swift.String, AnalyticsParameterKey {
    case videoPartCount
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias Manager = AnalyticsManager<TrimAnalytics.EventKind>
}
public protocol AnimatableViewFactory {
  func makeAnimatableView() -> AnimatableView
}
public enum EditorEffectKey : Swift.String {
  case name
  case type
  case renderer
  case path
  case id
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class EditorEffectsConfigHolder : ObjectiveC.NSObject {
  @objc deinit
  @objc override dynamic public init()
}
extension UIView {
  public func ext_addBorderConstraints(toView: UIKit.UIView!, offset: CoreGraphics.CGFloat = 0)
  public func ext_addLeftContraint(toView: UIKit.UIView!, offset: CoreGraphics.CGFloat = 0)
  public func ext_addRightContraint(toView: UIKit.UIView!, offset: CoreGraphics.CGFloat = 0)
  public func ext_addTopContraint(toView: UIKit.UIView!, offset: CoreGraphics.CGFloat = 0)
  public func ext_addBottomContraint(toView: UIKit.UIView!, offset: CoreGraphics.CGFloat = 0)
}
public struct EffectPickerAnalytics {
  public enum EventKind : Swift.String, AnalyticsEventKind {
    public static let domain: Swift.String
    case present
    case cancel
    case addEffect
    case removeEffect
    case done
    public var parameterKeys: [EffectPickerAnalytics.ParameterKey]? {
      get
    }
    public typealias ParameterKey = EffectPickerAnalytics.ParameterKey
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ParameterKey : Swift.String, AnalyticsParameterKey {
    case context
    case effectType
    case effectID
    case effectDuration
    case effectIDs
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias Manager = AnalyticsManager<EffectPickerAnalytics.EventKind>
}
public protocol CameraMasksProviding {
  var masks: [CameraMask] { get }
  func requestMask(mask: CameraMask, statusUpdateHandler: ((CameraMaskStatus) -> Swift.Void)?)
}
public protocol CameraMask {
  var id: Swift.UInt { get }
  var name: Swift.String { get }
  var previewImageURL: Foundation.URL { get }
  var status: CameraMaskStatus { get }
}
public enum CameraMaskStatus {
  case notDownloaded
  case downloaded(path: Foundation.URL)
  case downloading(progress: Swift.Float)
  case error(Swift.Error)
}
@_inheritsConvenienceInitializers public class TextEffectDrawer : VideoEditorEffectDrawer {
  required public init(imageInfo: ImageEffectInfo)
  required public init()
  public func createRenderer() -> EffectRenderer
  @objc deinit
}
public class CapturedImage {
  final public let duration: Foundation.TimeInterval
  public var capturedImage: CoreGraphics.CGImage
  public var image: CoreGraphics.CGImage?
  public init(capturedImage: CoreGraphics.CGImage, duration: Foundation.TimeInterval)
  @objc deinit
}
extension CapturedImage : VideoEditorImageAssetProtocol {
  public var shouldUseImageEffect: Swift.Bool {
    get
  }
  public func getOrPreloadImage() -> CoreGraphics.CGImage?
  public func unloadImage()
}
public protocol EffectRenderer {
  func render(in pixelBuffer: CoreVideo.CVPixelBuffer, allSources: [CoreVideo.CVPixelBuffer], sampleTime: CoreMedia.CMTime, startTime: CoreMedia.CMTime, path: Swift.String)
}
public enum VideoTextAligment : Swift.Int {
  case left
  case center
  case right
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol AnalyticsEngine : AnyObject {
  func report(error: Swift.Error, message: Swift.String)
  func report(message: Swift.String, parameters: [Swift.String : Any]?)
}
public struct VideoEditorTrimMetadata : Swift.Codable {
  public var url: Foundation.URL
  public var imageData: Foundation.Data?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct MusicEditorMetadata : Swift.Codable {
  public var tracks: [MusicEditorTrack]
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct MusicEditorTrack : Swift.Codable {
  public var url: Foundation.URL
  public var originalURL: Foundation.URL
  public var title: Swift.String
  public var id: Swift.Int64
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct VideoEditorMetadata : Swift.Codable {
  public let effectsOnVideoMetadata: [EffectOnVideoMetadata]?
  public let colorOnVideoMetadata: ColorOnVideoMetadata?
  public let textOnVideoMetadata: [TextOnVideoMetadata]?
  public let gifOnVideoMetadata: [GIFOnVideoMetadata]?
  public let videoInteractiveMetadata: VideoInteractiveMetadata
  public var videoMetadata: VideoMetadata?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ColorOnVideoMetadata : Swift.Codable {
  public let title: Swift.String
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct EffectOnVideoMetadata : Swift.Codable {
  public let startTime: TimeMetadata
  public let endTime: TimeMetadata
  public let effectId: Swift.UInt
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct TextOnVideoMetadata : Swift.Codable {
  public let imageData: Foundation.Data?
  public let textParams: TextParams
  public let startTime: TimeMetadata
  public let endTime: TimeMetadata
  public let coordinatesParams: CoordinatesParams
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct VideoMetadata : Swift.Codable {
  public let isSlideShow: Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct GIFOnVideoMetadata : Swift.Codable {
  public let id: Swift.String
  public let imageData: Foundation.Data?
  public let startTime: TimeMetadata
  public let endTime: TimeMetadata
  public let coordinatesParams: CoordinatesParams
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct CoordinatesParams : Swift.Codable {
  public let transform: CoreGraphics.CGAffineTransform
  public let frame: CoreGraphics.CGRect
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct ColorParams : Swift.Codable {
  public let red: CoreGraphics.CGFloat?
  public let green: CoreGraphics.CGFloat?
  public let blue: CoreGraphics.CGFloat?
  public let alpha: CoreGraphics.CGFloat?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct TextParams : Swift.Codable {
  public let text: Swift.String?
  public let textFont: Swift.String?
  public let fontName: Swift.String?
  public let fontSize: CoreGraphics.CGFloat?
  public let textAligment: Swift.Int?
  public let textColor: ColorParams?
  public let backgroundColor: ColorParams?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct TimeMetadata : Swift.Codable {
  public let seconds: Swift.Double
  public let timescale: CoreMedia.CMTimeScale
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension TimeMetadata {
  public init(cmTime: CoreMedia.CMTime)
  public func getCMTime() -> CoreMedia.CMTime
}
public struct VideoInteractiveMetadata : Swift.Codable {
  public var interactiveQuestionMetadata: [InteractiveQuestionMetadata]
  public var interactivePollMetadata: [InteractivePollMetadata]
  public var interactiveInterestMetadata: [InteractiveInterestMetadata]
  public var interactiveTestMetadata: [InteractiveTestMetadata]
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct InteractiveQuestionMetadata : Swift.Codable {
  public let imageData: Foundation.Data?
  public let text: Swift.String
  public let gradientColors: [ColorParams]?
  public let textColor: ColorParams?
  public let coordinatesParams: CoordinatesParams
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct InteractivePollMetadata : Swift.Codable {
  public let imageData: Foundation.Data?
  public let titleText: Swift.String
  public let leftCardText: Swift.String
  public let rightCardText: Swift.String
  public let coordinatesParams: CoordinatesParams
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct InteractiveInterestMetadata : Swift.Codable {
  public let imageData: Foundation.Data?
  public let title: Swift.String
  public let coordinatesParams: CoordinatesParams
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct InteractiveTestMetadata : Swift.Codable {
  public let imageData: Foundation.Data?
  public let gradientColors: [ColorParams]?
  public let textColor: ColorParams?
  public let title: Swift.String
  public let fields: [InteractiveTestFieldMetaData]
  public let coordinatesParams: CoordinatesParams
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct InteractiveTestFieldMetaData : Swift.Codable {
  public let answer: Swift.String
  public let isAnswer: Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension SmallActivityIndicatorConfiguration {
  public static var config: SmallActivityIndicatorConfiguration {
    get
  }
}
extension FullScreenActivityConfiguration {
  public static var config: FullScreenActivityConfiguration {
    get
  }
}
extension WatermarkConfiguration {
  public static var config: WatermarkConfiguration {
    get
  }
}
public protocol EffectTextAreaConfig : AnyObject {
  var areaName: Swift.String? { get }
}
public protocol TextEditSelectionColorBehavior {
  func setColorView(_ view: UIKit.UIView, selected: Swift.Bool, animated: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers public class ExposureAnimationView : UIKit.UIView, AnimatableView {
  @objc override dynamic public func draw(_ rect: CoreGraphics.CGRect)
  public func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  public func stop()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public class EffectModel {
  public var url: Foundation.URL?
  public var name: Swift.String?
  public init(url: Foundation.URL)
  public init(name: Swift.String)
  @objc deinit
}
public protocol NibLoadable : AnyObject {
  static var nib: UIKit.UINib { get }
}
extension NibLoadable {
  public static var nib: UIKit.UINib {
    get
  }
}
extension NibLoadable where Self : UIKit.UIView {
  public static func loadFromNib() -> Self
}
public protocol EffectCollectionViewDelegate : AnyObject {
  func applyDidStart(effect: EffectViewModel)
  func applyDidEnd()
}
public class ServiceFactory {
  final public let sdk: SDKService
  public var analytics: AnalyticsEngine
  final public let videoOverlayObjectRepository: VideoOverlayObjectRepository
  public var giphyApi: GiphyAPI {
    get
    set
  }
  public var gifImageRepository: GIFImageRepository {
    get
  }
  public var config: VideoEditorConfig {
    get
    set
  }
  final public let effectsManager: EffectsManaging
  public init(camera: CameraModule, config: VideoEditorConfig, analytics: AnalyticsEngine?)
  @objc deinit
}
public struct EditorAnalytics {
  public enum EventKind : Swift.String, AnalyticsEventKind {
    public static let domain: Swift.String
    case appearEffects
    case cancel
    case done
    public var parameterKeys: [EditorAnalytics.ParameterKey]? {
      get
    }
    public typealias ParameterKey = EditorAnalytics.ParameterKey
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ParameterKey : Swift.String, AnalyticsParameterKey {
    case videoPartsCount
    case musicId
    case visualEffectIds
    case colorEffectId
    case timeEffectIds
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias Manager = AnalyticsManager<EditorAnalytics.EventKind>
}
@objc @_inheritsConvenienceInitializers public class ImageCropperView : UIKit.UIView {
  public var image: UIKit.UIImage? {
    get
    set
  }
  public var croppingInfo: ImageCroppingInfo {
    get
  }
  @objc override dynamic public func awakeFromNib()
  @objc override dynamic public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum CaptureButtonMode {
  case video
  case mixed
  public static func == (a: CaptureButtonMode, b: CaptureButtonMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @_inheritsConvenienceInitializers public class PhotoVideoCaptureButtonViewController : UIKit.UIViewController {
  weak public var delegate: VideoEditorCaptureButtonDelegate?
  public var configuration: RecordButtonConfiguration?
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension PhotoVideoCaptureButtonViewController : VideoEditorCaptureButton {
  public func updateVideoRecordingProgress(_ captureProgress: Swift.Double)
  public func changeViewToIdleState()
  public func changeViewToCaptureState()
}
@_inheritsConvenienceInitializers public class GifEffectDrawer : VideoEditorEffectDrawer {
  required public init(sequence: ImagesSequence)
  required public init()
  public func createRenderer() -> EffectRenderer
  @objc deinit
}
public protocol AnalyticsEventKind : Swift.RawRepresentable where Self.RawValue == Swift.String {
  associatedtype ParameterKey : AnalyticsParameterKey
  static var domain: Swift.String { get }
  var parameterKeys: [Self.ParameterKey]? { get }
}
extension AnalyticsEventKind {
  public var id: Swift.String {
    get
  }
}
public protocol AnalyticsParameterKey : Swift.Hashable, Swift.RawRepresentable where Self.RawValue == Swift.String {
}
public class AnalyticsManager<Kind> where Kind : AnalyticsEventKind {
  public typealias ParameterKey = Kind.ParameterKey
  public init(analyticsEngine: AnalyticsEngine)
  public func log(_ eventKind: Kind, _ parameters: [AnalyticsManager<Kind>.ParameterKey : Any]? = nil)
  public func set(_ value: Any?, forKey key: AnalyticsManager<Kind>.ParameterKey)
  public func log(error: Swift.Error, message: Swift.String)
  @objc deinit
}
public struct GalleryAnalytics {
  public enum EventKind : Swift.String, AnalyticsEventKind {
    public static let domain: Swift.String
    case present
    case multichoiceOn
    case done
    public var parameterKeys: [GalleryAnalytics.ParameterKey]? {
      get
    }
    public typealias ParameterKey = GalleryAnalytics.ParameterKey
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ParameterKey : Swift.String, AnalyticsParameterKey {
    case isMultichoiceOn
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias Manager = AnalyticsManager<GalleryAnalytics.EventKind>
}
public typealias GetPaginatedListHandler<T> = (Result<T>, Swift.Bool) -> Swift.Void
@objc public class GiphyAPI : ObjectiveC.NSObject {
  public init(apiKey: Swift.String)
  public func cancelTask(with url: Foundation.URL)
  public func cancelAllTasks()
  public func getData(from url: Foundation.URL, compeletionQueue: Dispatch.DispatchQueue, completion: @escaping (Result<Foundation.Data>) -> Swift.Void)
  public func getTrendingGIFObjects(byPageNumber pageNumber: Swift.Int, completion: @escaping GetPaginatedListHandler<[GiphyImage]>)
  public func getGIFObjects(byPageNumber pageNumber: Swift.Int, searchQuery: Swift.String, completion: @escaping GetPaginatedListHandler<[GiphyImage]>)
  @objc override dynamic public init()
  @objc deinit
}
extension String {
  public func lookUpForImage() -> UIKit.UIImage?
}
public class RecorderInteractor {
  public init(presenter: RecorderPresenterProtocol, sdk: SDKServicing, analytics: RecorderAnalytics.Manager?, recorderConfiguration: RecorderConfiguration, mode: CaptureButtonMode)
  @objc deinit
}
extension RecorderInteractor : AudioPlayerDelegate {
  public func playerPlaysFrameAtTime(_ time: Foundation.TimeInterval)
  public func didEndPlaying()
}
public class MaskModel : Swift.Hashable, Swift.Comparable {
  final public let name: Swift.String
  final public let imageUrl: Foundation.URL
  final public let url: Foundation.URL
  final public let downloadType: ContentLocationType
  final public let id: Swift.UInt
  public var progress: Swift.Float?
  public var progressHandler: ((Swift.Float) -> Swift.Void)?
  public var image: UIKit.UIImage?
  convenience public init(url: Foundation.URL)
  convenience public init(name: Swift.String, imageUrl: Foundation.URL, downloadType: ContentLocationType, id: Swift.UInt)
  public init(name: Swift.String, imageUrl: Foundation.URL, url: Foundation.URL, downloadType: ContentLocationType, id: Swift.UInt)
  public static func == (lhs: MaskModel, rhs: MaskModel) -> Swift.Bool
  public static func < (lhs: MaskModel, rhs: MaskModel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension MaskModel : CameraMask {
  public var previewImageURL: Foundation.URL {
    get
  }
  public var status: CameraMaskStatus {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class PreviewSingleVideoViewController : UIKit.UIViewController, PlayablePreview, OverlayEditorPlayablePreview {
  weak public var playerDelegate: PlayerDelegate? {
    get
    set
  }
  public var previewView: UIKit.UIView {
    get
  }
  weak public var overlayEditorPlayerDelegate: OverlayEditorPlayerDelegate? {
    get
    set
  }
  public var overlayEditorAdoptablePlayer: AVFoundation.AVPlayer? {
    get
  }
  public var currentTime: Foundation.TimeInterval {
    get
  }
  public var videoDuration: Swift.Double {
    get
  }
  public var videoDurationInCMTime: CoreMedia.CMTime {
    get
  }
  public var currentTimeInCMTime: CoreMedia.CMTime {
    get
  }
  public var isPlaying: Swift.Bool {
    get
  }
  public var adoptablePlayer: PlayerAdoptable? {
    get
    set
  }
  public var player: Playable? {
    get
    set
  }
  weak public var previewPlayerDelegate: PreviewPlayerDelegate? {
    get
    set
  }
  public init(itemToPlay: Playable)
  @objc deinit
  public func updateViewFrame()
  public func startPlay(loop: Swift.Bool = true, fixedSpeed: Swift.Bool = false)
  public func startPlay(loop: Swift.Bool, fixedSpeed: Swift.Bool, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime)
  public func stopPlay()
  public func pausePlay()
  public func resumePlay()
  public func smoothlySeek(to time: CoreMedia.CMTime)
  public func reloadPreview()
  public func reloadPreview(shouldAutoStart: Swift.Bool)
  public func startStopPlay(loop: Swift.Bool, fixedSpeed: Swift.Bool)
  public func seek(to time: CoreMedia.CMTime)
  public func replacePlayer(_ newPlayer: Playable)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension PreviewSingleVideoViewController : PreviewPlayerDelegate, OverlayEditorPlayerDelegate {
  public func playerPlaysFrameAtTime(_ time: CoreMedia.CMTime)
  public func didEndPlaying()
}
public struct MusicPickerAnalytics {
  public enum EventKind : Swift.String, AnalyticsEventKind {
    public static let domain: Swift.String
    case present
    case cancel
    case select
    case remove
    case done
    public var parameterKeys: [MusicPickerAnalytics.ParameterKey]? {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public typealias ParameterKey = MusicPickerAnalytics.ParameterKey
  }
  public enum ParameterKey : Swift.String, AnalyticsParameterKey {
    case context
    case musicId
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias Manager = AnalyticsManager<MusicPickerAnalytics.EventKind>
}
public enum ContentLocationType {
  case remote
  case local
  public static func == (a: ContentLocationType, b: ContentLocationType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol EffectViewModel : AnyObject {
  var type: EffectType { get }
  var image: UIKit.UIImage? { get set }
  var title: Swift.String? { get }
  var id: Swift.UInt { get }
  var progress: Swift.Float? { get set }
  var progressHandler: ((Swift.Float) -> Swift.Void)? { get set }
  var downloadType: ContentLocationType { get }
  func isEqual(to model: EffectViewModel) -> Swift.Bool
}
extension EffectModel : EffectViewModel {
  public var downloadType: ContentLocationType {
    get
  }
  public var progress: Swift.Float? {
    get
    set
  }
  public var progressHandler: ((Swift.Float) -> Swift.Void)? {
    get
    set
  }
  public var id: Swift.UInt {
    get
  }
  public func isEqual(to model: EffectViewModel) -> Swift.Bool
  public var type: EffectType {
    get
  }
  public var image: UIKit.UIImage? {
    get
    set
  }
  public var title: Swift.String? {
    get
  }
}
extension MaskModel : EffectViewModel {
  public func isEqual(to model: EffectViewModel) -> Swift.Bool
  public var type: EffectType {
    get
  }
  public var title: Swift.String? {
    get
  }
}
extension VideoEditorFilterModel : EffectViewModel {
  public var downloadType: ContentLocationType {
    get
  }
  public var progress: Swift.Float? {
    get
    set
  }
  public var progressHandler: ((Swift.Float) -> Swift.Void)? {
    get
    set
  }
  public func isEqual(to model: EffectViewModel) -> Swift.Bool
  public var type: EffectType {
    get
  }
  public var image: UIKit.UIImage? {
    get
    set
  }
  public var title: Swift.String? {
    get
  }
}
public protocol SDKBeautyEffectManaging : AnyObject {
  var isBeatificationEnabled: Swift.Bool { get set }
  func toggleBeautification() -> Swift.Bool
}
public protocol AnimatableView : UIKit.UIView {
  func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  func stop()
}
public protocol CountdownTimerAnimatableView : AnimatableView {
  var countdownDigit: Swift.Int { get set }
}
public struct RecordedVideoCover {
  public var image: UIKit.UIImage
  public var time: CoreMedia.CMTime
  public init(image: UIKit.UIImage, time: CoreMedia.CMTime)
}
public class CoverExtractor {
  public init(videoEditorService: VideoEditorServicing)
  public func create(at time: CoreMedia.CMTime) -> RecordedVideoCover
  @objc deinit
}
public protocol MusicApplicable {
  func applyMusic(from file: Foundation.URL, title: Swift.String, id: Swift.Int64)
  func removeMusic()
}
public protocol BeautyEffectManaging {
  var enabled: Swift.Bool { get set }
  var applyHandler: ((Swift.String?) -> Swift.Void)? { get set }
}
public class BeautyEffectManager : BeautyEffectManaging {
  public var applyHandler: ((Swift.String?) -> Swift.Void)?
  public var enabled: Swift.Bool {
    get
    set
  }
  public init()
  public func enable()
  public func disable()
  @objc deinit
}
public enum OutputServiceError : Swift.Error {
  case notEnoughSpace
  public static func == (a: OutputServiceError, b: OutputServiceError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum Styles {
}
extension Styles {
  public enum TextEdit {
    public static let palette: [VideoTextColorPair]
  }
}
@_hasMissingDesignatedInitializers public class EffectsFactory {
  public static func glitch2EffectRenderer() -> EffectRenderer
  public static func cathodeEffectRenderer() -> EffectRenderer
  public static func polaroidEffectRenderer() -> EffectRenderer
  public static func soulEffectRenderer() -> EffectRenderer
  public static func zoomEffectRenderer() -> EffectRenderer
  public static func flashEffectRenderer() -> EffectRenderer
  public static func raveEffectRenderer() -> EffectRenderer
  public static func acidEffectRenderer() -> EffectRenderer
  public static func tvFoamEffectRenderer() -> EffectRenderer
  public static func vhsEffectRenderer() -> EffectRenderer
  public static func colorEffectRenderer() -> EffectRenderer
  public static func glitchEffectRenderer() -> EffectRenderer
  public static func gifEffectRenderer(sequence: ImagesSequence) -> EffectRenderer
  public static func textEffectRenderer(imageInfo: ImageEffectInfo) -> EffectRenderer
  public static func maskEffectRenderer() -> EffectRenderer
  @objc deinit
}
public protocol ScrollBarManagerProviding : AnyObject {
  func getScrollBarManager() -> ScrollBarManageable
}
public protocol ScrollBarManageable : AnyObject {
  func setScrollBarType(with type: ScrollBarTypes)
  func showScrollBar()
  func hideScrollBar()
  func setScrollBarEnabled(_ enabled: Swift.Bool)
}
public enum ScrollBarTypes {
  case dynamic
  case `static`
  public static func == (a: ScrollBarTypes, b: ScrollBarTypes) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class ScrollBarManagerAdapter : ScrollBarManageable {
  public init(manager: ScrollBarManageable)
  final public func setScrollBarType(with type: ScrollBarTypes)
  final public func showScrollBar()
  final public func hideScrollBar()
  final public func setScrollBarEnabled(_ enabled: Swift.Bool)
  @objc deinit
}
public enum VideoEditorCaptureButtonState {
  case idle
  case capture
  public static func == (a: VideoEditorCaptureButtonState, b: VideoEditorCaptureButtonState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol VideoEditorCaptureButton : UIKit.UIViewController {
  var delegate: VideoEditorCaptureButtonDelegate? { get set }
  var configuration: RecordButtonConfiguration? { get set }
  func updateVideoRecordingProgress(_ captureProgress: Swift.Double)
  func changeViewToIdleState()
  func changeViewToCaptureState()
}
public protocol VideoEditorCaptureButtonDelegate : AnyObject {
  func aptureButtonGotTapEvent()
  func aptureButtonGotLongTapEvent()
  func aptureButtonDropLongTapEvent()
}
extension AlertViewController.AlertType : Swift.Equatable {}
extension AlertViewController.AlertType : Swift.Hashable {}
extension CameraModuleSessionType : Swift.Equatable {}
extension CameraModuleSessionType : Swift.Hashable {}
extension AudioWriterStatus : Swift.Equatable {}
extension AudioWriterStatus : Swift.Hashable {}
extension CameraAlertType : Swift.Equatable {}
extension CameraAlertType : Swift.Hashable {}
extension DeviceModel : Swift.Equatable {}
extension DeviceModel : Swift.Hashable {}
extension DeviceModel : Swift.RawRepresentable {}
extension RecorderAnalytics.EventKind : Swift.Equatable {}
extension RecorderAnalytics.EventKind : Swift.Hashable {}
extension RecordMode : Swift.Equatable {}
extension RecordMode : Swift.Hashable {}
extension RecordMode : Swift.RawRepresentable {}
extension BackButtonConfiguration.Position : Swift.Equatable {}
extension BackButtonConfiguration.Position : Swift.Hashable {}
extension AdditionalEffectsButtonConfiguration.Position : Swift.Equatable {}
extension AdditionalEffectsButtonConfiguration.Position : Swift.Hashable {}
extension AdditionalEffectsButtonConfiguration.Position : Swift.RawRepresentable {}
extension AdditionalEffectsButtonConfiguration.ButtonType : Swift.Equatable {}
extension AdditionalEffectsButtonConfiguration.ButtonType : Swift.Hashable {}
extension AdditionalEffectsButtonConfiguration.ButtonType : Swift.RawRepresentable {}
extension AdditionalEffectsButtonConfiguration.TitlePosition : Swift.Equatable {}
extension AdditionalEffectsButtonConfiguration.TitlePosition : Swift.Hashable {}
extension WatermarkConfiguration.WatermarkPosition : Swift.Equatable {}
extension WatermarkConfiguration.WatermarkPosition : Swift.Hashable {}
extension TimeResult : Swift.Equatable {}
extension TimeResult : Swift.Hashable {}
extension EffectType : Swift.Equatable {}
extension EffectType : Swift.Hashable {}
extension VideoRecordSpeed : Swift.Equatable {}
extension VideoRecordSpeed : Swift.Hashable {}
extension VideoRecordSpeed : Swift.RawRepresentable {}
extension SDKInputServiceMode : Swift.Equatable {}
extension SDKInputServiceMode : Swift.Hashable {}
extension TrimAnalytics.EventKind : Swift.Equatable {}
extension TrimAnalytics.EventKind : Swift.Hashable {}
extension EditorEffectKey : Swift.Equatable {}
extension EditorEffectKey : Swift.Hashable {}
extension EditorEffectKey : Swift.RawRepresentable {}
extension EffectPickerAnalytics.EventKind : Swift.Equatable {}
extension EffectPickerAnalytics.EventKind : Swift.Hashable {}
extension VideoTextAligment : Swift.Equatable {}
extension VideoTextAligment : Swift.Hashable {}
extension VideoTextAligment : Swift.RawRepresentable {}
extension EditorAnalytics.EventKind : Swift.Equatable {}
extension EditorAnalytics.EventKind : Swift.Hashable {}
extension CaptureButtonMode : Swift.Equatable {}
extension CaptureButtonMode : Swift.Hashable {}
extension GalleryAnalytics.EventKind : Swift.Equatable {}
extension GalleryAnalytics.EventKind : Swift.Hashable {}
extension MusicPickerAnalytics.EventKind : Swift.Equatable {}
extension MusicPickerAnalytics.EventKind : Swift.Hashable {}
extension ContentLocationType : Swift.Equatable {}
extension ContentLocationType : Swift.Hashable {}
extension OutputServiceError : Swift.Equatable {}
extension OutputServiceError : Swift.Hashable {}
extension ScrollBarTypes : Swift.Equatable {}
extension ScrollBarTypes : Swift.Hashable {}
extension VideoEditorCaptureButtonState : Swift.Equatable {}
extension VideoEditorCaptureButtonState : Swift.Hashable {}
